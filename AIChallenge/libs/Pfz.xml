<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pfz</name>
    </assembly>
    <members>
        <member name="T:Pfz.Caching.GCUtils">
            <summary>
            Some methods and events to interact with garbage collection. You can 
            keep an object alive during the next collection or register to know 
            when a collection has just happened. This is useful if you don't use
            WeakReferences, but know how to free memory if needed. For example, 
            you can do a TrimExcess to your lists to free some memory.
            
            Caution: GC.KeepAlive keeps the object alive until that line of code,
            while GCUtils.KeepAlive keeps the object alive until the next 
            generation.
            </summary>
        </member>
        <member name="M:Pfz.Caching.GCUtils.KeepAlive(System.Object)">
            <summary>
            Keeps an object alive at the next collection. This is useful for WeakReferences as an way
            to guarantee that recently used objects will not be immediatelly collected. At the next
            generation, you can call KeepAlive again, making the object alive for another generation.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Pfz.Caching.GCUtils.Expire(System.Object)">
            <summary>
            Expires an object. Is the opposite of KeepAlive.
            </summary>
            <param name="item"></param>
            <returns>true if the object was in the KeepAlive list, false otherwise.</returns>
        </member>
        <member name="M:Pfz.Caching.GCUtils.ExpireAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Expires all items in a collection using a single lock.
            </summary>
            <param name="collection">The collection of items to expire.</param>
        </member>
        <member name="P:Pfz.Caching.GCUtils.ProcessMemory">
            <summary>
            Gets or sets a value that indicates how much memory the process
            can use without freeing it's caches.
            Note that such value does not affect how often GC occurs and is
            not the size of the cache, it only says: If my process is not using
            more than X memory, caches don't need to be erased.
            The default value is 0 mb.
            </summary>
        </member>
        <member name="E:Pfz.Caching.GCUtils.Collected">
            <summary>
            This event is called after a GarbageCollection has just finished,
            in another thread. As this happens after the collection has finished,
            all other threads are running too, so you must guarantee that
            your event is thread safe.
            </summary>
        </member>
        <member name="T:Pfz.Caching.InternalWeakDelegate">
            <summary>
            A class used as the base class to implement weak delegates.
            See WeakDelegate.From method implementations to see how it works.
            </summary>
        </member>
        <member name="M:Pfz.Caching.InternalWeakDelegate.#ctor(System.Delegate)">
            <summary>
            Creates this weak-delegate class based as a copy of the given 
            delegate handler.
            </summary>
            <param name="handler">The handler to copy information from.</param>
        </member>
        <member name="M:Pfz.Caching.InternalWeakDelegate.Invoke(System.Object[])">
            <summary>
            Invokes this delegate with the given parameters.
            </summary>
            <param name="parameters">The parameters to be used by the delegate.</param>
        </member>
        <member name="P:Pfz.Caching.InternalWeakDelegate.Method">
            <summary>
            Gets the method used by this delegate.
            </summary>
        </member>
        <member name="T:Pfz.Caching.IReference">
            <summary>
            Interface implemented by ThreadUnsafeReference and Reference classes.
            This is the untyped version.
            </summary>
        </member>
        <member name="T:Pfz.Caching.IReferenceData">
            <summary>
            Interface used by 
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.IValueContainer">
            <summary>
            Untyped value container.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.IValueContainer.Value">
            <summary>
            Gets or sets the value of this container.
            </summary>
        </member>
        <member name="P:Pfz.Caching.IReferenceData.HandleType">
            <summary>
            Gets the HandleType or this reference-data.
            </summary>
        </member>
        <member name="M:Pfz.Caching.IReference.GetData">
            <summary>
            Gets a copy of this reference HandleType and Value at once.
            </summary>
        </member>
        <member name="M:Pfz.Caching.IReference.Set(System.Runtime.InteropServices.GCHandleType,System.Object)">
            <summary>
            Sets the HandleType and Value at once.
            </summary>
        </member>
        <member name="P:Pfz.Caching.IReference.HandleType">
            <summary>
            Gets or sets the HandleType of this reference.
            </summary>
        </member>
        <member name="T:Pfz.Caching.IReference`1">
            <summary>
            Interface implemented by ThreadUnsafeReference and Reference classes.
            </summary>
        </member>
        <member name="T:Pfz.Caching.IReferenceData`1">
            <summary>
            Typed version of IReferenceData.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.IValueContainer`1">
            <summary>
            Typed value container.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.IValueContainer`1.Value">
            <summary>
            Gets or sets the rightly typed value of this container.
            </summary>
        </member>
        <member name="M:Pfz.Caching.IReference`1.GetData">
            <summary>
            Gets a typed copy of HandleType and Value at once.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.Caching.IReference`1.Set(System.Runtime.InteropServices.GCHandleType,`0)">
            <summary>
            Sets HandleType and Value at once.
            </summary>
        </member>
        <member name="T:Pfz.Caching.KeepAliveGCHandle">
            <summary>
            This struct works like a KeepAliveWeakReference, but it is internal
            as it's uses the GCHandle directly, and can leak memory if used
            unproperly.
            </summary>
        </member>
        <member name="T:Pfz.Caching.KeepAliveWeakReference">
            <summary>
            This is a WeakReference class with KeepAlive capability.
            Everytime you get the Target from this WeakReference, it calls the GCUtils.KeepAlive.
            This is a very simple way to use weak-references only to your objects and also
            keep them alive if they are used frequently.
            </summary>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference.#ctor(System.Object)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target.
            </summary>
            <param name="target">The target of this KeepAliveWeakReference.</param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference.#ctor(System.Object,System.Boolean)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target and allowing to trackResurrection.
            The Caching framework does not use this constructor, it is only here to keep the functionality
            of the second parameter present in the System.WeakReference constructor.
            </summary>
            <param name="target">The target of this WeakReference.</param>
            <param name="trackResurrection">Boolean indicating if this WeakReference must trackResurrection.</param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference.#ctor(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target, allowing to trackResurrection and
            allowing you to tell if immediateExpiration is allowed. The other two constructors always
            do a KeepAlive, so they don't allow immediateExpiration.
            </summary>
            <param name="target">The target of this WeakReference.</param>
            <param name="trackResurrection">Boolean indicating if this WeakReference must trackResurrection.</param>
            <param name="allowImmediateExpiration">
            If true, the target can be collected in the next collection.
            If false, it will be kept alive at the next collection.
            </param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Simple keeping the serialization constructor present in WeakReference.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Pfz.Caching.KeepAliveWeakReference.Target">
            <summary>
            Overrides the WeakReference.Target, so it calls KeepAlive while gets or sets the Target.
            </summary>
        </member>
        <member name="P:Pfz.Caching.KeepAliveWeakReference.TargetAllowingExpiration">
            <summary>
            This is equivalent to a custom WeakReference target, as it's gets or sets the target
            without calling KeepAlive. Keep in mind that when an external code uses WeakReference,
            you can pass a KeepAliveWeakReference as a parameter, and the conventional Target that
            is used by default will have the KeepAlive effect.
            </summary>
        </member>
        <member name="T:Pfz.Caching.KeepAliveWeakReference`1">
            <summary>
            A typed version of weak-reference.
            Note that it simple hides the untyped Target and TargetAllowingExpiration.
            If you cast this object as a simple WeakReference you can still set
            an invalid typed target to it. This is only a helper class to avoid
            manual casts.
            </summary>
            <typeparam name="T">The type of the objects used by this weak-reference.</typeparam>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference`1.#ctor(System.Object)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target.
            </summary>
            <param name="target">The target of this KeepAliveWeakReference.</param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference`1.#ctor(System.Object,System.Boolean)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target and allowing to trackResurrection.
            The Caching framework does not use this constructor, it is only here to keep the functionality
            of the second parameter present in the System.WeakReference constructor.
            </summary>
            <param name="target">The target of this WeakReference.</param>
            <param name="trackResurrection">Boolean indicating if this WeakReference must trackResurrection.</param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference`1.#ctor(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Constructs a KeepAliveWeakReference pointing to a target, allowing to trackResurrection and
            allowing you to tell if immediateExpiration is allowed. The other two constructors always
            do a KeepAlive, so they don't allow immediateExpiration.
            </summary>
            <param name="target">The target of this WeakReference.</param>
            <param name="trackResurrection">Boolean indicating if this WeakReference must trackResurrection.</param>
            <param name="allowImmediateExpiration">
            If true, the target can be collected in the next collection.
            If false, it will be kept alive at the next collection.
            </param>
        </member>
        <member name="M:Pfz.Caching.KeepAliveWeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Simple keeping the serialization constructor present in WeakReference.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Pfz.Caching.KeepAliveWeakReference`1.Target">
            <summary>
            Gets or sets the typed target, calling GCUtils.KeepAlive() 
            while doing it.
            </summary>
        </member>
        <member name="P:Pfz.Caching.KeepAliveWeakReference`1.TargetAllowingExpiration">
            <summary>
            Gets or sets the typed-target, without calling GCUtils.KeepAlive().
            </summary>
        </member>
        <member name="T:Pfz.Caching.Reference`1">
            <summary>
            This class is a GCHandle wrapper that allows you to reference other objects
            using WeakReference, Strong or other reference types.
            This class is thread and abort-safe, but uses lock(this) in its methods, 
            so never hold a lock over a reference, as this can cause dead-locks.
            </summary>
        </member>
        <member name="T:Pfz.ICloneable`1">
            <summary>
            Typed version of ICloneable interface.
            </summary>
        </member>
        <member name="M:Pfz.ICloneable`1.Clone">
            <summary>
            Returns a typed clone of this object.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.#ctor">
            <summary>
            Creates a new empty reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.#ctor(`0,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            Creates a new reference using the given value and handle type.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Finalize">
            <summary>
            Frees the handle.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Dispose">
            <summary>
            Frees the handle immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Set(System.Runtime.InteropServices.GCHandleType,`0)">
            <summary>
            Sets the data of this reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.GetData">
            <summary>
            Gets the data of this reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.GetHashCode">
            <summary>
            Gets the HashCode of the Value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Equals(System.Object)">
            <summary>
            Compares the Value of this reference with the value of another reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Equals(Pfz.Caching.ThreadUnsafeReference{`0})">
            <summary>
            Compares the Value of this reference with the value of another reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.Reference`1.Clone">
            <summary>
            Creates a copy of this reference.
            </summary>
        </member>
        <member name="P:Pfz.Caching.Reference`1.Value">
            <summary>
            Gets or sets the value pointed by the handle.
            </summary>
        </member>
        <member name="P:Pfz.Caching.Reference`1.HandleType">
            <summary>
            Gets or sets the handle type.
            </summary>
        </member>
        <member name="T:Pfz.Caching.ReferenceData`1">
            <summary>
            Struct that holds both HandleType and Value of a Referece.
            This avoids doing two locks, for example.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.#ctor(`0,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            Creates a new ReferenceData with the given information.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.Equals(System.Object)">
            <summary>
            Compares if this reference data equals another object.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.Equals(Pfz.Caching.ReferenceData{`0})">
            <summary>
            Compares if this reference data is idential to another one.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.GetHashCode">
            <summary>
            Gets the hashcode for this reference data.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.op_Equality(Pfz.Caching.ReferenceData{`0},Pfz.Caching.ReferenceData{`0})">
            <summary>
            Compares two referece data for equality.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ReferenceData`1.op_Inequality(Pfz.Caching.ReferenceData{`0},Pfz.Caching.ReferenceData{`0})">
            <summary>
            Compares two referece data for inequality.
            </summary>
        </member>
        <member name="P:Pfz.Caching.ReferenceData`1.HandleType">
            <summary>
            Gets the HandleType.
            </summary>
        </member>
        <member name="P:Pfz.Caching.ReferenceData`1.Value">
            <summary>
            Gets the Value.
            </summary>
        </member>
        <member name="T:Pfz.Caching.ThreadUnsafeReference`1">
            <summary>
            This class is a GCHandle wrapper that allows you to reference other objects
            using WeakReference, Strong or other reference types.
            It has a dispose and a destructor, but it is NOT thread safe, in the sense
            that changing the type or disposing from many threads can cause exceptions.
            Even not being thread-safe, this class is abort-safe.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.#ctor">
            <summary>
            Creates a new empty reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.#ctor(`0,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            Creates a new reference using the given value and handle type.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Finalize">
            <summary>
            Frees the handle.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Dispose">
            <summary>
            Frees the handle immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.GetData">
            <summary>
            Gets the data of this Reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Set(System.Runtime.InteropServices.GCHandleType,`0)">
            <summary>
            Sets the data of this reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.GetHashCode">
            <summary>
            Gets the HashCode of the Value.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Equals(System.Object)">
            <summary>
            Compares the Value of this reference with the value of another reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Equals(Pfz.Caching.ThreadUnsafeReference{`0})">
            <summary>
            Compares the Value of this reference with the value of another reference.
            </summary>
        </member>
        <member name="M:Pfz.Caching.ThreadUnsafeReference`1.Clone">
            <summary>
            Creates a copy of this reference.
            </summary>
        </member>
        <member name="P:Pfz.Caching.ThreadUnsafeReference`1.Value">
            <summary>
            Gets or sets the value pointed by the handle.
            </summary>
        </member>
        <member name="P:Pfz.Caching.ThreadUnsafeReference`1.HandleType">
            <summary>
            Gets or sets the handle type.
            </summary>
        </member>
        <member name="T:Pfz.Caching.WeakArray`1">
            <summary>
            This is an array of objects, where each object can be collected.
            Each time an item is accessed by the indexer, a GCUtils.KeepAlive
            is done.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
        </member>
        <member name="T:Pfz.Threading.ReaderWriterSafeDisposable">
            <summary>
            This class is useful if you need to implement the dispose pattern
            in a thread-safe manner.
            It guarantees that dispose will be called only once, even if many 
            threads try to call Dispose at once. In your code, you must lock 
            DisposeLock, check if the object is disposed and call anything that 
            must be guaranteed to run before dispose inside the lock block.
            </summary>
        </member>
        <member name="T:Pfz.IAdvancedDisposable">
            <summary>
            Interface for disposable objects that can inform they are already
            disposed without throwing an exception.
            </summary>
        </member>
        <member name="P:Pfz.IAdvancedDisposable.WasDisposed">
            <summary>
            Gets a value indicating if the object was already disposed.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ReaderWriterSafeDisposable.Finalize">
            <summary>
            Calls Dispose(false);
            </summary>
        </member>
        <member name="M:Pfz.Threading.ReaderWriterSafeDisposable.Dispose">
            <summary>
            Calls Dispose(true) to release all resources.
            Guarantees that only a single call to Dispose(true) is done 
            even if  this method is invoked multiple times or by many 
            different threads at the same time.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ReaderWriterSafeDisposable.Dispose(System.Boolean)">
            <summary>
            Implement this method to release all resources used by this object.
            </summary>
            <param name="disposing">
            This parameter is true if it was called by a user call to Dispose(),
            and false if it was called by a destructor. If false, you don't need
            to release managed resources (in general, you don't need to set any
            variables to null or even reference other objects, only freeing 
            "unsafe" pointers).
            </param>
        </member>
        <member name="M:Pfz.Threading.ReaderWriterSafeDisposable.CheckUndisposed">
            <summary>
            Checks if the objects is disposed. If it is, throws an 
            ObjectDisposedException. Call this as the first method inside a 
            using(DisposeLock.SomeLockType())
            {
            	CheckUndisposed(); 
            	... your protected code here ...
            }
            
            or simple call it without any lock if you only want to throw
            an exception if the object is already disposed but such a call
            is read-only.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ReaderWriterSafeDisposable.WasDisposed">
            <summary>
            Returns true if a call to Dispose was already done (or still in
            progress in another thread). If it is true, you can't continue
            to use your object.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ReaderWriterSafeDisposable.DisposeLock">
            <summary>
            This is the lock used during dispose. You may want to lock
            some of your code against dispose using this lock.
            The preferred way to use it is: 
            using(DisposeLock.SomeLockType())
            {
            	CheckUndisposed();
            	
            	... your protected code here ...
            }
            </summary>
        </member>
        <member name="F:Pfz.Caching.WeakArray`1.Empty">
            <summary>
            Gets an empty WeakArray.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakArray`1.#ctor(System.Int32)">
            <summary>
            Creates the array with the given length.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakArray`1.Dispose(System.Boolean)">
            <summary>
            Releases the handles used by the array.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakArray`1.ToArray">
            <summary>
            Converts this WeakArray into a common array.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakArray`1.ToList">
            <summary>
            Converts this WeakArray into a list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakArray`1.GetEnumerator">
            <summary>
            Gets an enumerator for this array, so foreach can be done.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakArray`1.Length">
            <summary>
            Gets the number of items in this array.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakArray`1.Item(System.Int32)">
            <summary>
            Gets or sets the items in this array.
            </summary>
            <param name="index">The index of the item to get or set.</param>
        </member>
        <member name="T:Pfz.Caching.WeakDelegateSet">
            <summary>
            This class acts as a hashset for delegates, but allows the
            Targets to be collected, working as if the Delegates where 
            WeakDelegates.
            The original idea was to make this a generic class, but it
            is not possible to use Delegate as a constraint (where T: Delegate).
            
            To use, implement your event like:
            private WeakDelegateSet _myEvent = new WeakDelegateSet();
            public event EventHandler MyEvent
            {
            	add
            	{
            		_myEvent.Add(value);
            	}
            	remove
            	{
            		_myEvent.Remove(value);
            	}
            	
            And when you want to invoke MyEvent, you call:
            	_myEvent.Invoke(this, EventArgs.Empty);
            }
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.#ctor">
            <summary>
            Creates a new WeakDelegateSet.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.Dispose(System.Boolean)">
            <summary>
            Unregisters the WeakDelegateSet from GCUtils.Collected.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.Clear">
            <summary>
            Clears the delegate set.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.Add(System.Delegate)">
            <summary>
            Adds a new handler to the delegate set.
            </summary>
            <param name="handler">The handler to add.</param>
            <returns>true if the delegate was new to the set, false otherwise.</returns>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.Remove(System.Delegate)">
            <summary>
            Removes a handler from the delegate set.
            </summary>
            <param name="handler">The handler to remove.</param>
            <returns>true if the item was in the set, false otherwise.</returns>
        </member>
        <member name="M:Pfz.Caching.WeakDelegateSet.Invoke(System.Object[])">
            <summary>
            Invokes all the handlers in the set with the given parameters.
            </summary>
            <param name="parameters">The parameters to be used in the invoke of each handler.</param>
        </member>
        <member name="T:Pfz.Caching.WeakDictionary`2">
            <summary>
            This is a dictionary that allow values to be collected.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.#ctor">
            <summary>
            Creates the dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.Dispose(System.Boolean)">
            <summary>
            Frees all handles used to know if an item was collected or not.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.Clear">
            <summary>
            Clears all items in this dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Gets the value for the given key or, if it does not exist, creates it, adds it and
            returns it.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item to this dictionary. Throws an exception if an item
            with the same key already exists.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.Remove(`0)">
            <summary>
            Removes an item with the given key from the dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.ContainsKey(`0)">
            <summary>
            Gets a value indicating if an item with the specified key exists.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator with all key/value pairs that exist in
            this dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.ToList">
            <summary>
            Gets a list with all non-collected key/value pairs.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates the dictionary from serialization info.
            Actually, it does not load anything, as if everything was
            collected.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakDictionary`2.Count">
            <summary>
            Gets the number of items in this dictionary.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakDictionary`2.Item(`0)">
            <summary>
            Gets or sets a value for the specified key.
            Returns null if the item does not exist. The indexer, when
            used as an IDictionary throws an exception when the item does
            not exist.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakDictionary`2.Keys">
            <summary>
            Gets the Keys that exist in this dictionary.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakDictionary`2.Values">
            <summary>
            Gets a copy of the values that exist in this dictionary.
            </summary>
        </member>
        <member name="T:Pfz.Caching.WeakHashSet`1">
            <summary>
            HashSet class which allows items to be collected.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.#ctor">
            <summary>
            Creates a new instance of the WeakHashSet class.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.Dispose(System.Boolean)">
            <summary>
            Releases all the GCHandles used internally.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.Clear">
            <summary>
            Clears the contents of this weak hashset.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.Add(`0)">
            <summary>
            Tries to add an item in this hashset.
            Returns true if the item was added, or false if the item was
            already present.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.Contains(`0)">
            <summary>
            Returns true if the given item is in this hashset, false otherwise.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.ToList">
            <summary>
            Gets a list with all the non-collected items present in this
            hashset.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.Remove(`0)">
            <summary>
            Removes the given item from this hashset.
            Returns a value indicating if the given item was in the hashset.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates the class from serialization. At this level, does not read
            anything, as if everything was collected.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Does not add any items to the serialization info, as if everything
            was collected.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakHashSet`1.GetEnumerator">
            <summary>
            Gets an enumerator over the non-collected items in this hashset.
            </summary>
        </member>
        <member name="T:Pfz.Caching.WeakKeyDictionary`2">
            <summary>
            A dictionary were keys are weakreferences. This is useful if you need
            to "extend" existing classes. For example, if you want to add a Tag
            property to any object. The way this dictionary works, you can add
            items to a given object, which will be kept while the object is alive,
            but if the object dies (is collected) they will be allowed to be 
            with it.
            </summary>
            <typeparam name="TKey">The type of the key, which must be a class.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.#ctor">
            <summary>
            Creates the WeakKeyDictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.Dispose(System.Boolean)">
            <summary>
            Frees all handles.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.Clear">
            <summary>
            Clears all items in the dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item to the dictionary, or throws an exception if an item
            with the same key already exists.
            </summary>
            <param name="key">The key of the item to add.</param>
            <param name="value">The value of the item to add.</param>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.Remove(`0)">
            <summary>
            Tries to remove an item from the dictionary, and returns a value 
            indicating if an item with the specified key existed.
            </summary>
            <param name="key">The key of the item to remove.</param>
            <returns>true if an item with the given key existed, false otherwise.</returns>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.ContainsKey(`0)">
            <summary>
            Checks if an item with the given key exists in this dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value with a given key.
            </summary>
            <param name="key">The key of the item to try to get.</param>
            <param name="value">
            The variable that will receive the found value, or the default value 
            if an item with the given key does not exist.
            </param>
            <returns>
            true if an item with the given key was found and stored in value
            parameter, false otherwise.
            </returns>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.ToList">
            <summary>
            Creates a list with all non-collected keys and values.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakKeyDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator of all non-collected keys and values.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakKeyDictionary`2.Count">
            <summary>
            Gets the number of the items in the dictionary. This value
            is not that useful, as just after getting it the number of 
            items can change by a collection.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakKeyDictionary`2.Item(`0)">
            <summary>
            Gets or sets a value for the given key.
            While getting, if the value does not exist an exception is thrown.
            This can happen if the value was collected, so avoid using getter,
            use TryGetValue instead.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="P:Pfz.Caching.WeakKeyDictionary`2.Keys">
            <summary>
            Returns all the non-collected keys.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakKeyDictionary`2.Values">
            <summary>
            Gets all the values still alive in this dictionary.
            </summary>
        </member>
        <member name="T:Pfz.Caching.WeakList`1">
            <summary>
            A list that only keeps weak-references to its items.
            Ideal if at some point you only need to do a for-each over all the
            non-collected items. Use WeakHashSet if you need to remove the items
            or calls Contains frequently.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.#ctor">
            <summary>
            Creates an empty weak-list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.#ctor(System.Int32)">
            <summary>
            Creates an empty weak-list using the given minCapacity to it.
            </summary>
            <param name="initialCapacity">The initialCapacity of the list. The default value is 32.</param>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.Dispose(System.Boolean)">
            <summary>
            Releases all handles.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.Clear">
            <summary>
            Clears all the items in the list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.Add(`0)">
            <summary>
            Adds an item to the list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.ToList">
            <summary>
            Gets a strong-list with all the non-collected items present
            in this list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.Contains(`0)">
            <summary>
            Returns true if an item exists in the collection, false otherwise.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.IndexOf(`0)">
            <summary>
            Gets the IndexOf an item in this list, or -1 if it does not exist.
            Note that just after checking for the index of an item, it could
            be collected, so this is not really useful.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.RemoveAt(System.Int32)">
            <summary>
            Removes an item at a given index.
            Note that, different from normal lists, the following items do
            not move and the count is not immediatelly updated.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.Remove(`0)">
            <summary>
            Tries to remove an item from this list and returns if it was
            found and removed. Note that the Count and the following items 
            are not automatically updated, as this will only happen in the next
            garbage collection.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.GetEnumerator">
            <summary>
            Gets an enumerator over the non-collected items of this
            list.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates the WeakList from the serialization info.
            </summary>
        </member>
        <member name="M:Pfz.Caching.WeakList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates serialization info.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakList`1.Count">
            <summary>
            Gets an approximate count of the items added.
            </summary>
        </member>
        <member name="P:Pfz.Caching.WeakList`1.Item(System.Int32)">
            <summary>
            Gets or sets an item at a given index.
            </summary>
        </member>
        <member name="T:Pfz.Collections.ActualValueEnumerator`1">
            <summary>
            This enumerator returns a "next value" every time the actual value is set, but
            if many sets are done before the client is able to process them, the 
            intermediate values are lost, so only the "actual" one is got.
            </summary>
            <typeparam name="T">The type of the values.</typeparam>
        </member>
        <member name="T:Pfz.Collections.IFastEnumerator`1">
            <summary>
            A typed version of FastEnumerator. Only reference types are valid.
            </summary>
            <typeparam name="T">The type of the items to enumerate.</typeparam>
        </member>
        <member name="M:Pfz.Collections.IFastEnumerator`1.GetNext">
            <summary>
            Gets the next value, or null if there are no more values.
            </summary>
            <returns>The next value, or null if there are no more values.</returns>
        </member>
        <member name="M:Pfz.Collections.ActualValueEnumerator`1.Dispose(System.Boolean)">
            <summary>
            Only sets the event so any waiting thread is free.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ActualValueEnumerator`1.GetNext">
            <summary>
            Gets the next value.
            </summary>
        </member>
        <member name="P:Pfz.Collections.ActualValueEnumerator`1.ActualValue">
            <summary>
            Gets or sets the actual value.
            </summary>
        </member>
        <member name="T:Pfz.Collections.AutoTrimDictionary`2">
            <summary>
            Dictionary that uses a ReaderWriterLock for its accesses (so the call to each method
            is thread-safe) and also gets "trimmed" automatically when garbage collections occur.
            
            It is also capable of auto-collecting Values that are empty collections and does not 
            accept null values (or remove an item set to null).
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.#ctor">
            <summary>
            Creates a new instance of AutoTrimDictionary.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.Dispose(System.Boolean)">
            <summary>
            Unregisters this dictionary from GCUtils.Collected.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.Add(`0,`1)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.ContainsKey(`0)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.Remove(`0)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.Clear">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimDictionary`2.GetEnumerator">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimDictionary`2.MustRemoveEmptyCollections">
            <summary>
            Gets or sets a value indicating that values that are empty-collections must be removed
            during a collection.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimDictionary`2.Keys">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimDictionary`2.Values">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimDictionary`2.Item(`0)">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimDictionary`2.Count">
            <summary>
            Redirects the call to the real dictionary, in a thread-safe manner.
            </summary>
        </member>
        <member name="T:Pfz.Collections.AutoTrimHashSet`1">
            <summary>
            A very simple hashset collection that's thread-safe and also calls TrimExcess automatically.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.#ctor">
            <summary>
            Creates a new hashset.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new hashset, using the given comparer.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.Dispose(System.Boolean)">
            <summary>
            Unregisters this from GCUtils.Collected.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.Clear">
            <summary>
            Clears this hashset.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.Add(`0)">
            <summary>
            Tries to add an item to the hashset. Returns true if the item was added.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.Remove(`0)">
            <summary>
            Removes an item. Returns true if the item was found and removed.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.Contains(`0)">
            <summary>
            Verifies if an item exists.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the values from this hashset to an array.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.ToList">
            <summary>
            Gets a list that is a copy of this hashset.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.GetEnumerator">
            <summary>
            Gets an enumerator over a copy of this hashset.
            </summary>
        </member>
        <member name="M:Pfz.Collections.AutoTrimHashSet`1.ToArray">
            <summary>
            Returns an array that's a copy of this hashset.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimHashSet`1.Comparer">
            <summary>
            Returns the comparer used by this hashset.
            </summary>
        </member>
        <member name="P:Pfz.Collections.AutoTrimHashSet`1.Count">
            <summary>
            Gets the number of items in this hashset.
            </summary>
        </member>
        <member name="T:Pfz.Collections.EnumeratorDistributor`1">
            <summary>
            This class is responsible for distributing a single enumerator
            among many enumerator readers, considering such readers can
            "loose" some of the items.
            This is useful for senting, for example, web-cam frames. A high-speed
            client can receive all frames, while a slow client can receive frame
            1, then frame 6, frame 12... but will still receive the "most recent"
            frames.
            You can inherit this class the the MultiClientEnumerator themselves
            if you must only send the difference between frames.
            </summary>
            <typeparam name="T">
            The type of the item that the original enumerator returns.
            </typeparam>
        </member>
        <member name="T:Pfz.Threading.ThreadSafeExceptionAwareDisposable">
            <summary>
            A ThreadSafeDisposable inheritor capable of keeping information of why
            it was disposed, considering it is disposed by an exception. This is 
            largelly used in the Remoting framework, as some exceptions can
            dispose the objects, but for the user is better to know the original
            exception, not the ObjectDisposedException.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ThreadSafeDisposable">
            <summary>
            This class is useful if you need to implement the dispose pattern
            in a thread-safe manner.
            It guarantees that dispose will be called only once, even if many 
            threads try to call Dispose at once. In your code, you must lock 
            DisposeLock, check if the object is disposed and call anything that 
            must be guaranteed to run before dispose inside the lock block.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeDisposable.Finalize">
            <summary>
            Calls Dispose(false);
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeDisposable.Dispose">
            <summary>
            Calls Dispose(true) to release all resources.
            Guarantees that only a single call to Dispose(true) is done 
            even if  this method is invoked multiple times or by many 
            different threads at the same time.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeDisposable.Dispose(System.Boolean)">
            <summary>
            Implement this method to release all resources used by this object.
            </summary>
            <param name="disposing">
            This parameter is true if it was called by a user call to Dispose(),
            and false if it was called by a destructor. If false, you don't need
            to release managed resources (in general, you don't need to set any
            variables to null or even reference other objects, only freeing 
            "unsafe" pointers).
            </param>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeDisposable.CheckUndisposed">
            <summary>
            Checks if the objects is disposed. If it is, throws an 
            ObjectDisposedException. Call this as the first method inside a 
            lock(DisposeLock)
            {
            	CheckUndisposed(); 
            	... your protected code here ...
            }
            
            or simple call it without any lock if you only want to throw
            an exception if the object is already disposed but such a call
            is read-only.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ThreadSafeDisposable.WasDisposed">
            <summary>
            Returns true if a call to Dispose was already done (or still in
            progress in another thread). If it is true, you can't continue
            to use your object.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ThreadSafeDisposable.DisposeLock">
            <summary>
            This is the lock used during dispose. You may want to lock
            some of your code against dispose using this lock.
            The preferred way to use it is: 
            lock(DisposeLock)
            {
            	CheckUndisposed();
            	
            	... your protected code here ...
            }
            </summary>
        </member>
        <member name="T:Pfz.IExceptionAwareDisposable">
            <summary>
            Interface that must be implemented by objects that are disposable
            and also capables of registering the Exception that caused the Dispose.
            </summary>
        </member>
        <member name="M:Pfz.IExceptionAwareDisposable.Dispose(System.Exception)">
            <summary>
            Disposes the object setting the Exception that was responsible for
            it's disposal.
            </summary>
        </member>
        <member name="P:Pfz.IExceptionAwareDisposable.DisposeException">
            <summary>
            Gets the Exception that caused the dispose of this object, or null.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeExceptionAwareDisposable.Dispose(System.Exception)">
            <summary>
            Disposes the actual object, setting the DisposeException property.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadSafeExceptionAwareDisposable.CheckUndisposed">
            <summary>
            New version of CheckUndisposed, which will throw the appropriate
            exception instead of ObjectDisposedException if this object was
            disposed by another exception.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ThreadSafeExceptionAwareDisposable.DisposeException">
            <summary>
            Gets the Exception that caused this object to be disposed, or null.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributor`1.#ctor(Pfz.Collections.IFastEnumerator{`0})">
            <summary>
            Creates a new Distributor over the given real enumerator.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributor`1.Dispose(System.Boolean)">
            <summary>
            Disposes the base enumerator and the clients actually connected.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributor`1.CreateClient">
            <summary>
            Creates a client for this enumerator.
            Inheritors can initialize additional information before returning 
            the enumerator client to you.
            </summary>
        </member>
        <member name="P:Pfz.Collections.EnumeratorDistributor`1.BaseEnumerator">
            <summary>
            Gets the BaseEnumerator used by this distributor.
            </summary>
        </member>
        <member name="E:Pfz.Collections.EnumeratorDistributor`1.Disposed">
            <summary>
            Called when this object is disposed.
            </summary>
        </member>
        <member name="P:Pfz.Collections.EnumeratorDistributor`1.ActualValue">
            <summary>
            Gets the Actual value without waiting.
            </summary>
        </member>
        <member name="T:Pfz.Collections.EnumeratorDistributorClient`1">
            <summary>
            This class connects to a EnumeratorDistributor and is able
            to use GetNext to get a next frame when one is available, while it is 
            also able to "loose" values if the real enumerator is running faster 
            than this client. This is useful when getting frames from a web-cam, 
            for example.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributorClient`1.#ctor(Pfz.Collections.EnumeratorDistributor{`0})">
            <summary>
            Creates a new multi-client enumerator connected to the given distributor.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributorClient`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this enumerator and removes it from
            the distributor list.
            </summary>
        </member>
        <member name="M:Pfz.Collections.EnumeratorDistributorClient`1.GetNext">
            <summary>
            Gets the actual value of the distributor or waits until a new
            value is available.
            </summary>
        </member>
        <member name="P:Pfz.Collections.EnumeratorDistributorClient`1.Distributor">
            <summary>
            Gets the Distributor used by this enumerator.
            </summary>
        </member>
        <member name="T:Pfz.Collections.FastEnumeratorWrapper`1">
            <summary>
            This class creates an IFastEnumerator wrapper over a custom enumerator.
            Note that this class must be used in the server, so it passes the 
            IFastEnumerator to it's client. Using it locally or in the clients will
            probably make things slower.
            </summary>
        </member>
        <member name="M:Pfz.Collections.FastEnumeratorWrapper`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new FastEnumerator over the given enumerable.
            </summary>
        </member>
        <member name="M:Pfz.Collections.FastEnumeratorWrapper`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Creates a new FastEnumerator over the given enumerator.
            </summary>
        </member>
        <member name="M:Pfz.Collections.FastEnumeratorWrapper`1.Dispose">
            <summary>
            Disposes the internal enumerator.
            </summary>
        </member>
        <member name="M:Pfz.Collections.FastEnumeratorWrapper`1.GetNext">
            <summary>
            Gets the next value, or null.
            </summary>
        </member>
        <member name="T:Pfz.Collections.ImmutableArray`1">
            <summary>
            Struct that holds an immutable array.
            The methods that "change" the array will, in fact, create copies of it.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates an immutable array that is a copy from the given collection.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.GetHashCode">
            <summary>
            Gets the hash-code of the array, which is the exclusive combination
            of all items hash-codes.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.Equals(System.Object)">
            <summary>
            Compares this immutable array to another object.
            Returns false if the other object is not of the same type.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.Equals(Pfz.Collections.ImmutableArray{`0})">
            <summary>
            Compares this immutable array to another one.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.Add(`0)">
            <summary>
            Creates a new immutable array, which all the items from this array and
            a new one at the end.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.RemoveLast">
            <summary>
            Creates a copy of this immutable array, without the last item.
            Throws an IndexOutOfRangeException if this is an empty array.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.IndexOf(`0)">
            <summary>
            Returns the index of the first found value in this array.
            If the value does not exists, returns -1.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.op_Equality(Pfz.Collections.ImmutableArray{`0},Pfz.Collections.ImmutableArray{`0})">
            <summary>
            Compares two ImmutableArrays for equality.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.op_Inequality(Pfz.Collections.ImmutableArray{`0},Pfz.Collections.ImmutableArray{`0})">
            <summary>
            Compares two ImmutableArrays for inequality.
            </summary>
        </member>
        <member name="M:Pfz.Collections.ImmutableArray`1.GetEnumerator">
            <summary>
            Gets an enumerator that will returns all items in this array.
            </summary>
        </member>
        <member name="P:Pfz.Collections.ImmutableArray`1.Length">
            <summary>
            Gets the length of this array.
            </summary>
        </member>
        <member name="P:Pfz.Collections.ImmutableArray`1.Item(System.Int32)">
            <summary>
            Gets an item by the given index from this array.
            </summary>
        </member>
        <member name="T:Pfz.Collections.IReadOnlyDictionary">
            <summary>
            Interface used to get dictionaries as read-only.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary.ContainsKey(System.Object)">
            <summary>
            Returns true if an item with the given key exists.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary.ContainsValue(System.Object)">
            <summary>
            Returns true if the given value exists in the dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary.TryGetValue(System.Object,System.Object@)">
            <summary>
            Tries to get a value by its key.
            Returns true if the a value with the given key was found, false otherwise.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary.Count">
            <summary>
            Gets the number of items in the dictionary.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary.Keys">
            <summary>
            Gets all keys.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary.Values">
            <summary>
            Gets all values.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary.Item(System.Object)">
            <summary>
            Gets an item by its key.
            </summary>
        </member>
        <member name="T:Pfz.Collections.IReadOnlyDictionary`2">
            <summary>
            Interface used to get dictionaries as read-only.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if an item with the given key exists.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary`2.ContainsValue(`1)">
            <summary>
            Returns true if the given value exists in the dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value for the given key.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary`2.Keys">
            <summary>
            Gets all keys.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary`2.Values">
            <summary>
            Gets all values.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets an item by its key.
            </summary>
        </member>
        <member name="T:Pfz.Collections.IReadOnlyHashSet`1">
            <summary>
            Interface returned by AsReadOnly extension method to make a HashSet read-only.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.Contains(`0)">
            <summary>
            Verifies if a given item exists in the hashset.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.CopyTo(`0[])">
            <summary>
            Copies the elements of this hashset to an array.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of this hashset to an array.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of this hashset to an array.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="M:Pfz.Collections.IReadOnlyHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check HashSet for details.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyHashSet`1.Comparer">
            <summary>
            Gets the comparer used by this hashset.
            </summary>
        </member>
        <member name="P:Pfz.Collections.IReadOnlyHashSet`1.Count">
            <summary>
            Gets the number of items in this hashset.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.Date">
            <summary>
            Class that represents a Date without Time.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.Parse(System.String)">
            <summary>
            Parses the given text as a Date using the default format.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new date by the specified year, month and day.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.#ctor(System.DateTime)">
            <summary>
            Creates a new date from a DateTime. The time information is lost.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.#ctor(System.Int32)">
            <summary>
            Creates a Date object from an integer value previously got from
            the AsInteger property of another Date.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_Equality(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if this two dates are equal.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_Inequality(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if two dates are different.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_LessThan(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if the first date is less than the second date.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_GreaterThan(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if the first date is greater than the second.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_LessThanOrEqual(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if the first date is less than or equal to the second.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_GreaterThanOrEqual(Pfz.DataTypes.Date,Pfz.DataTypes.Date)">
            <summary>
            Compares if the first date is greater than or equal to the second.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_Implicit(Pfz.DataTypes.Date)~System.DateTime">
            <summary>
            Implicit convertion to DateTime object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_Explicit(System.DateTime)~Pfz.DataTypes.Date">
            <summary>
            Explicit cast from DateTime to Date value.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.op_Addition(Pfz.DataTypes.Date,Pfz.DataTypes.Time)">
            <summary>
            Returns a new DateTime composed of the given date and time.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.Add(Pfz.DataTypes.Time)">
            <summary>
            Returns a DateTime composed of this date + time.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.GetHashCode">
            <summary>
            Gets the HashCode of the AsInteger value of this date.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.Equals(System.Object)">
            <summary>
            Compares if this Date equals another object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.Equals(Pfz.DataTypes.Date)">
            <summary>
            Returns true if this Date equals another Date.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.ToString">
            <summary>
            Converts this Date to a string representation.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Date.CompareTo(Pfz.DataTypes.Date)">
            <summary>
            Compares this date to another date.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.DefaultFormat">
            <summary>
            Gets or sets the default format used to display Date
            strings.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.Today">
            <summary>
            Gets Today as a Date object.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.Year">
            <summary>
            Gets the Year.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.Month">
            <summary>
            Gets the Month.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.Day">
            <summary>
            Gets the Day.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Date.AsInteger">
            <summary>
            Converts this Date value to an integer representation.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.EmailString">
            <summary>
            Simple wrapper for string with validations for Emails.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.#ctor(System.String)">
            <summary>
            Creates a new EmailString with the given value.
            Throws an exception if the e-mail is invalid.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.Validate(System.String)">
            <summary>
            Validates if the given string is a valid e-mail.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.ToString">
            <summary>
            Gets the real-string.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.GetHashCode">
            <summary>
            Gets the hashcode of the real string.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.Equals(System.Object)">
            <summary>
            Compares this object to another object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.Equals(Pfz.DataTypes.EmailString)">
            <summary>
            Compares this PasswordString with another PasswordString.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.op_Equality(Pfz.DataTypes.EmailString,Pfz.DataTypes.EmailString)">
            <summary>
            Compares the equality of two email strings.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EmailString.op_Inequality(Pfz.DataTypes.EmailString,Pfz.DataTypes.EmailString)">
            <summary>
            Compares the inequality of two email strings.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.EnumWrapper">
            <summary>
            Wrapper for enums that shows their DisplayName (which can be set by DisplayNameAttribute)
            when ToString is invoked.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.#ctor(System.Enum)">
            <summary>
            Creates a new wrapper over the given enum.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.Equals(System.Object)">
            <summary>
            Returns true if the passed object is another enum-wrapper for the same enum value.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.Equals(Pfz.DataTypes.EnumWrapper)">
            <summary>
            Returns true if the other enum has the same enum value than this.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.GetHashCode">
            <summary>
            Gets the hashcode of the enum value or zero if it is null.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.ToString">
            <summary>
            Returns the display name of the enum value, or null if it is empty.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.op_Equality(Pfz.DataTypes.EnumWrapper,Pfz.DataTypes.EnumWrapper)">
            <summary>
            Compares two enum wrappers for equality.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.EnumWrapper.op_Inequality(Pfz.DataTypes.EnumWrapper,Pfz.DataTypes.EnumWrapper)">
            <summary>
            Compares two enum wrappers for inequality.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.EnumWrapper.Value">
            <summary>
            Gets the original enum value.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.PasswordString">
            <summary>
            Wrapper struct, so factories can threat this type of string differently,
            doing encription or showing them in password boxes.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.#ctor(System.String)">
            <summary>
            Creates a new PasswordString with the given value.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.ToString">
            <summary>
            Gets the real-string.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.GetHashCode">
            <summary>
            Gets the hashcode of the real string.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.Equals(System.Object)">
            <summary>
            Compares this object to another object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.Equals(Pfz.DataTypes.PasswordString)">
            <summary>
            Compares this PasswordString with another PasswordString.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.op_Equality(Pfz.DataTypes.PasswordString,Pfz.DataTypes.PasswordString)">
            <summary>
            Compares two password strings for equality.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PasswordString.op_Inequality(Pfz.DataTypes.PasswordString,Pfz.DataTypes.PasswordString)">
            <summary>
            Compares two password strings for inequality.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.PropertyError">
            <summary>
            Class to be used when adding an error specific to one property.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PropertyError.#ctor(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Creates the error object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.PropertyError.ToString">
            <summary>
            Shows the error message.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.PropertyError.DefaultMessageFormat">
            <summary>
            Gets or sets the format used by default when generating the
            string of this error.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.PropertyError.Property">
            <summary>
            Gets the property that has an error.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.PropertyError.Error">
            <summary>
            Gets the error.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.PropertyError.MessageFormat">
            <summary>
            Gets or sets the format to generate the error message on ToString.
            {0} is the DisplayName of the property.
            {1} is the error object or, if the error is an exception, the
            exception.Message.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.Time">
            <summary>
            A struct that represents Time only (instead of Date and Time).
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.Parse(System.String)">
            <summary>
            Parses the given text as a Time using the default format.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.#ctor(System.Int32)">
            <summary>
            Creates a new time value from a given integer time, which
            must be previously got from a Time.AsInteger.
            </summary>
            <param name="integerTime"></param>
        </member>
        <member name="M:Pfz.DataTypes.Time.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new time object from the specified parameters.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.#ctor(System.DateTime)">
            <summary>
            Creates a new time object from the specified dateTime, obviouly
            getting only the time part.
            </summary>
            <param name="dateTime"></param>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_Equality(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if two time objects are equal.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_Inequality(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if two time objects are different.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_LessThan(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if a time object is less than other.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_GreaterThan(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if a time object is greater than other.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_LessThanOrEqual(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if a time object is less than or equal to
            another.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_GreaterThanOrEqual(Pfz.DataTypes.Time,Pfz.DataTypes.Time)">
            <summary>
            Compares if a time value is greater than or equal to
            another.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_Implicit(Pfz.DataTypes.Time)~System.DateTime">
            <summary>
            Implicit convert a Time object to a DateTime object.
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Pfz.DataTypes.Time.op_Explicit(System.DateTime)~Pfz.DataTypes.Time">
            <summary>
            Explicit converts a DateTime object to a Time object.
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="M:Pfz.DataTypes.Time.GetHashCode">
            <summary>
            Gets the hashcode of this time object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.DataTypes.Time.Equals(System.Object)">
            <summary>
            Returns true if this time object equals another object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.Equals(Pfz.DataTypes.Time)">
            <summary>
            Returns true if this time object equals the value of
            another time object.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.Time.ToString">
            <summary>
            Gets the time formatted.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.DataTypes.Time.CompareTo(Pfz.DataTypes.Time)">
            <summary>
            Returns an integer value with the comparison result of 
            this time and another time. Negative value means this
            time is smaller than the other.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.DefaultFormat">
            <summary>
            Gets or sets the default format used to display Time values.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.Now">
            <summary>
            Gets the actual time, without date information.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.Hour">
            <summary>
            Gets the hour of this time object.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.Minute">
            <summary>
            Gets the minute of this time object.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.Second">
            <summary>
            Gets the second of this time object.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.Millisecond">
            <summary>
            Gets the millisecond of this time object.
            </summary>
        </member>
        <member name="P:Pfz.DataTypes.Time.AsInteger">
            <summary>
            Gets this value as an integer representation.
            </summary>
        </member>
        <member name="T:Pfz.DataTypes.TypeTypeConverter">
            <summary>
            A converter for the Type.
            It converts the type to and from strings.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.TypeTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns true for strings.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.TypeTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns true for strings.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.TypeTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Gets a type by it's full type name.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.TypeTypeConverter.ConvertFrom(System.String)">
            <summary>
            Gets a type by it's full type name.
            </summary>
        </member>
        <member name="M:Pfz.DataTypes.TypeTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Gets the full name of a type.
            </summary>
        </member>
        <member name="T:Pfz.DisplayNameAttribute">
            <summary>
            Allows you to se a different display name for an enum value,
            or simple put a DisplayName to fields, properties and other things.
            </summary>
        </member>
        <member name="M:Pfz.DisplayNameAttribute.#ctor(System.String)">
            <summary>
            Creates the display name attribute setting it's value.
            </summary>
            <param name="displayName">The displayName to use for this enum.</param>
        </member>
        <member name="P:Pfz.DisplayNameAttribute.DisplayName">
            <summary>
            Gets the display name for the enum value.
            </summary>
        </member>
        <member name="T:Pfz.DisposeAssurer">
            <summary>
            Class that guarantees that its value will be disposed, even if you forget to call dispose.
            </summary>
        </member>
        <member name="T:Pfz.DisposeAssurerBase">
            <summary>
            Class responsible for calling dispose of its value, even if this class itself is not properly disposed.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase.#ctor(System.IDisposable)">
            <summary>
            When inheriting this class, you should provide the value.
            If the value can't be guaranteed to be disposed later (system is out of memory now)
            it is disposed immediatelly and an exception is thrown.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase.Dispose">
            <summary>
            Immediatelly releases all resources used by this object.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase.Finalize">
            <summary>
            Will try to dispose the referenced object.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase.GetHashCode">
            <summary>
            Gets the hashcode of the value;
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase.Equals(System.Object)">
            <summary>
            Verifies if two DisposeAssures point to the same value.
            </summary>
        </member>
        <member name="P:Pfz.DisposeAssurerBase.Value">
            <summary>
            Gets the value of this DisposeCaller.
            </summary>
        </member>
        <member name="P:Pfz.DisposeAssurerBase.WasDisposed">
            <summary>
            Gets a value indicating if this object was already disposed.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurer.Create(System.IDisposable)">
            <summary>
            Creates a new DisposeAssurer for the given IDisposable value.
            In case of exception, the value is disposed.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurer.Create``1(``0)">
            <summary>
            Creates a rightly typed DisposeAssurer for the given value.
            In case of exception, the value is disposed.
            </summary>
        </member>
        <member name="P:Pfz.DisposeAssurer.Value">
            <summary>
            Gets the value of this instance.
            </summary>
        </member>
        <member name="T:Pfz.DisposeAssurer`1">
            <summary>
            Class that guarantees that it value will be disposed, even if you forget to call dispose.
            </summary>
        </member>
        <member name="T:Pfz.DisposeAssurerBase`1">
            <summary>
            Class responsible for calling dispose of its value, even if this class itself is not properly disposed.
            </summary>
        </member>
        <member name="M:Pfz.DisposeAssurerBase`1.#ctor(`0)">
            <summary>
            When inheriting this class, you should provide the value.
            If the value can't be guaranteed to be disposed later (system is out of memory now)
            it is disposed immediatelly and an exception is thrown.
            </summary>
        </member>
        <member name="P:Pfz.DisposeAssurerBase`1.Value">
            <summary>
            Gets the value of this DisposeCaller.
            </summary>
        </member>
        <member name="P:Pfz.DisposeAssurer`1.Value">
            <summary>
            Gets the value of this instance.
            </summary>
        </member>
        <member name="T:Pfz.Disposer">
            <summary>
            Class that does the pattern of checking for null, disposing the object and setting its variable to null.
            </summary>
        </member>
        <member name="M:Pfz.Disposer.Dispose``1(``0@)">
            <summary>
            Disposes the object if needed and sets its variable to null.
            </summary>
        </member>
        <member name="M:Pfz.Disposer.DisposeCollection``1(``0@)">
            <summary>
            Disposes all the items in a given collection.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.CallConstructorAttribute">
            <summary>
            Use this attribute in methods present in your interface that you want to call DuckCaster.GetStaticInterface
            or StructuralCaster.GetStaticInterface.
            This attribute will tell that such method, instead of be a call to a static method, will be a call to a
            compatible constructor.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.CastAttribute">
            <summary>
            Use this attribute in properties or methods of interfaces that you will use for Duck or Structural Castings.
            The Result of such property or method will also have its value casted, accordingly to this attribute.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.CastAttribute.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates a new CastResultAttribute.
            </summary>
            <param name="mustValidateStructure">If set to true (the default), a StructuralCaster.Cast will be used. Otherwise, a DuckCaster.Cast will be used.</param>
            <param name="mustUseSecurityToken">If set to true, Casts done will use the actual object securityToken. This will make the new casted result also be secured, but will also allow to recast to the real type (which can be a security problem, but needed sometimes).</param>
        </member>
        <member name="P:Pfz.DynamicObjects.CastAttribute.MustValidateStructure">
            <summary>
            Gets a value indicating if the structure will be validated (StructuralCaster.Cast) or not (DuckCaster.Cast).
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.CastAttribute.MustUseSecurityToken">
            <summary>
            Gets a value indicating if the security token of the actual object must be used when doing the cast.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.DelegateProxier">
            <summary>
            Class used to implement any delegate and call a proxy object to process the invokes.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.DelegateProxier.Proxy(Pfz.DynamicObjects.IProxyDelegate,System.Type)">
            <summary>
            Implementes a delegate and calls the given proxy.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.DuckCaster">
            <summary>
            Class responsible for creating instances of objects that implement a given interface for an object that
            has the needed characteristics but does not actually implement the interface (that is, the original object could
            be made to implement that interface, but it does not and, if you don't have a way to change the original object,
            this is the only solution).
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.DuckCaster.Cast(System.Object,System.Type,System.Object)">
            <summary>
            Tries to cast the given object to the given interface type.
            If the cast is not valid, tries to implement a proxy interface to redirect to it.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.DuckCaster.Cast``1(System.Object,System.Object)">
            <summary>
            Tries to cast the given object to the given interface type.
            If the cast is not valid, tries to implement a proxy interface to redirect to it.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.DuckCaster.GetStaticInterface``1(System.Type)">
            <summary>
            This method will generate an implemented object for interface type T, redirecting
            its methods, properties and events to the static properties, methods and events of
            a given type. This way, you can have "virtual static methods".
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.InterfaceProxier">
            <summary>
            Class capable of implementing interfaces, redirecting all their methods to a proxy object.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.InterfaceProxier.Proxy``1(Pfz.DynamicObjects.IProxyObject)">
            <summary>
            Implements an object that proxies the calls to interface T to the proxyObject.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.InterfaceProxier.Proxy(Pfz.DynamicObjects.IProxyObject,System.Type[])">
            <summary>
            Implements one or more interfaces, calling the given proxyObject for each call.
            Returns an object with all the given interfaces implemented.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.Internal.BaseDuck">
            <summary>
            Class used by the framework when generating duck-types.
            You don't need to use it.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuck.DuckCast``1(System.Object)">
            <summary>
            Casts the target of this object, instead of casting this object.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuck.StructuralCast``1(System.Object)">
            <summary>
            Casts the target of this object, instead of casting this object.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.Internal.BaseDuckForInstances">
            <summary>
            This class is used when emitting code for StructuralCaster.Cast.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForInstances.#ctor(System.Object,System.Object)">
            <summary>
            Used by emitted code.
            </summary>
        </member>
        <member name="F:Pfz.DynamicObjects.Internal.BaseDuckForInstances._target">
            <summary>
            Used by emitted code.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForInstances.GetTarget(System.Object)">
            <summary>
            Gets the Target object of interface calls.
            </summary>
        </member>
        <member name="F:Pfz.DynamicObjects.Internal.BaseDuckForInstances._securityToken">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForInstances.DuckCast``1(System.Object)">
            <summary>
            Recasts the source object if the securityToken is OK.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForInstances.StructuralCast``1(System.Object)">
            <summary>
            Recasts the source object if the securityToken is OK.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Internal.BaseDuckForInstances.HasSecurityToken">
            <summary>
            Gets a value indicating if a SecurityToken was used when creating the object.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.Internal.BaseDuckForTypes">
            <summary>
            This type is used by emitted code generated by StructuralCaster.GetStaticInterface.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForTypes.DuckCast``1(System.Object)">
            <summary>
            Re-casts the Type this objects references.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseDuckForTypes.StructuralCast``1(System.Object)">
            <summary>
            Re-casts the Type this objects references.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Internal.BaseDuckForTypes.Target">
            <summary>
            Gets the Type to which the calls are redirected.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.Internal.BaseImplementedProxy">
            <summary>
            This is the base class for the generated proxies of InterfaceImplementer and DelegateImplementer.
            You may use this if you need to know if the object was created dinamically or to know to which
            object the calls are redirected.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.Internal.BaseImplementedProxy.#ctor(System.Object)">
            <summary>
            Creates a new instance of this object, setting the ProxyObject.
            </summary>
        </member>
        <member name="F:Pfz.DynamicObjects.Internal.BaseImplementedProxy._proxyObject">
            <summary>
            This field is read by all auto-implemented methods that need to be redirected.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Internal.BaseImplementedProxy.ProxyObject">
            <summary>
            Gets the object to which the calls are redirected.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.InvokeDelegate_EventArgs">
            <summary>
            InvokeProperty - EventArgs
            This arguments class is used as the parameter for Before and After
            invoking a property get or set.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.Invoke_EventArgs">
            <summary>
            Base class for filling Invoke arguments.
            This base class generates the try/catch invoke pattern, where
            the CanInvoke can be set in the before event to stop the original
            method and after method to be invoked, and the Exception property
            is used to call the After event as a catch clause.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Invoke_EventArgs.CanInvoke">
            <summary>
            Only used in Before events to know if the original method and the After event
            must be invoked.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Invoke_EventArgs.Exception">
            <summary>
            Can be different than null if the After event is called as a Catch
            clause. You can set it again to null if you threat the exception.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.Invoke_EventArgs.Target">
            <summary>
            The wrapper object that is calling the event. This is different
            from sender, as the sender if the EventedWrapperGenerator.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeDelegate_EventArgs.Handler">
            <summary>
            The Handler to Invoke.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeDelegate_EventArgs.Parameters">
            <summary>
            The parameters.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeDelegate_EventArgs.Result">
            <summary>
            Gets or sets the Result.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.InvokeEvent_EventArgs">
            <summary>
            InvokeEvent - EventArgs. This arguments class is passed as parameter
            in before and after events of EventAdd and EventRemove.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeEvent_EventArgs.EventInfo">
            <summary>
            The EventInfo to which the handler must be added or removed.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeEvent_EventArgs.Handler">
            <summary>
            The Handler to add or remove to the event.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.InvokeMethod_EventArgs">
            <summary>
            InvokeMethod - EventArgs
            This arguments class is passed as parameter when a method is being 
            invoked.
            For generic method, the MethodInfo is a method already constructed
            from the type params.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeMethod_EventArgs.MethodInfo">
            <summary>
            The method info to invoke.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeMethod_EventArgs.GenericArguments">
            <summary>
            If the MethodInfo is a generic method, here are the GenericArguments (you can use this to call MakeGenericMethod).
            If the MethodInfo is not a generic method, this value must be null.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeMethod_EventArgs.Parameters">
            <summary>
            The parameters used to call the method.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeMethod_EventArgs.Result">
            <summary>
            In Before event, you must set the Result value of the method
            if you set the CanInvoke to false. If you set the result value
            without setting CanInvoke to false your result value will be lost.
            In the After event, this will be the value returned from the
            real method invocation.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.InvokeProperty_EventArgs">
            <summary>
            InvokeProperty - EventArgs
            This arguments class is used as the parameter for Before and After
            invoking a property get or set.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeProperty_EventArgs.PropertyInfo">
            <summary>
            The PropertyInfo of the property to invoke.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeProperty_EventArgs.Indexes">
            <summary>
            The indexes parameters for indexed properties or null.
            </summary>
        </member>
        <member name="P:Pfz.DynamicObjects.InvokeProperty_EventArgs.Value">
            <summary>
            For property gets, this property will refer to the result value.
            For property sets, this property will refer to the value passed
            as parameter to the set.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.IProxyDelegate">
            <summary>
            Interface that must be implemented by objects that will respond to
            dynamic-delegates generated by DelegateImplementer.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyDelegate.Invoke(System.Object[])">
            <summary>
            Method invoked when the delegate is invoked.
            </summary>
        </member>
        <member name="T:Pfz.DynamicObjects.IProxyObject">
            <summary>
            Interface that must be implemented by objects that want to be the proxies to calls done to
            any interface implemented by InterfaceImplementer class.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyObject.InvokeMethod(System.Reflection.MethodInfo,System.Type[],System.Object[])">
            <summary>
            Method invoked when a call to a method on the interface is done.
            </summary>
            <param name="methodInfo">The methodInfo being invoked.</param>
            <param name="genericArguments">If the method is generic, this parameter contains the generic arguments to build it.</param>
            <param name="parameters">The parameters to the method call.</param>
            <returns>You must return a value, if the methodInfo expects a result. Otherwise, return null.</returns>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyObject.InvokePropertyGet(System.Reflection.PropertyInfo,System.Object[])">
            <summary>
            Method invoked when trying to get a property value.
            </summary>
            <param name="propertyInfo">The propertyInfo of the property being read.</param>
            <param name="indexes">The indexes, if this is an indexed property.</param>
            <returns>You must return a valid value for the property.</returns>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyObject.InvokePropertySet(System.Reflection.PropertyInfo,System.Object[],System.Object)">
            <summary>
            Method invoked when trying to set a property value.
            </summary>
            <param name="propertyInfo">The propertyInfo of the property being set.</param>
            <param name="indexes">If this is an indexed property, the indexes of the value being set.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyObject.InvokeEventAdd(System.Reflection.EventInfo,System.Delegate)">
            <summary>
            Method invoked when trying to register into an event of an interface.
            </summary>
            <param name="eventInfo">The eventInfo describing the event.</param>
            <param name="handler">The handler to add.</param>
        </member>
        <member name="M:Pfz.DynamicObjects.IProxyObject.InvokeEventRemove(System.Reflection.EventInfo,System.Delegate)">
            <summary>
            Method invoked when trying to unregister from an event of an interface.
            </summary>
            <param name="eventInfo">The eventInfo describing the event.</param>
            <param name="handler">The handler to be removed.</param>
        </member>
        <member name="T:Pfz.DynamicObjects.StructuralCaster">
            <summary>
            Class responsable for casting objects to an interface type that they don't support, but have equivalent methods.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.StructuralCaster.Cast``1(System.Object,System.Object)">
            <summary>
            Casts an object to a given type.
            </summary>
        </member>
        <member name="M:Pfz.DynamicObjects.StructuralCaster.GetStaticInterface``1(System.Type)">
            <summary>
            Gets the static methods of a type into an interface.
            </summary>
        </member>
        <member name="T:Pfz.EnumParser">
            <summary>
            Class that adds generic Parse methods to enums.
            </summary>
        </member>
        <member name="M:Pfz.EnumParser.Parse``1(System.String)">
            <summary>
            Parses a value returning the typed enum.
            </summary>
            <typeparam name="T">The type of the enum.</typeparam>
            <param name="value">The value to parse.</param>
            <returns>The enum found.</returns>
        </member>
        <member name="M:Pfz.EnumParser.Parse``1(System.String,System.Boolean)">
            <summary>
            Parses a value returning the typed enum.
            </summary>
            <typeparam name="T">The type of the enum.</typeparam>
            <param name="value">The value to parse.</param>
            <param name="ignoreCase">Case must be ignored or not?</param>
            <returns>The enum found.</returns>
        </member>
        <member name="T:Pfz.ExceptionAwareStream">
            <summary>
            Stream class that has a Dispose receiving an Exception as the cause
            of the dispose. Calling any method after the dispose will throw a
            new ObjectDisposedException with that exception as the inner exception.
            </summary>
        </member>
        <member name="M:Pfz.ExceptionAwareStream.Dispose(System.Exception)">
            <summary>
            Disposes the stream and sets the DisposeException.
            </summary>
        </member>
        <member name="M:Pfz.ExceptionAwareStream.Dispose(System.Boolean)">
            <summary>
            Implemented to guarantee that it will be executed only once.
            You must reimplement DoDispose, as this method is sealed.
            </summary>
        </member>
        <member name="M:Pfz.ExceptionAwareStream.OnDispose(System.Boolean)">
            <summary>
            Does the effective dispose.
            </summary>
        </member>
        <member name="M:Pfz.ExceptionAwareStream.CheckUndisposed">
            <summary>
            Checks if this object was disposed. If it is, throws an exception.
            </summary>
        </member>
        <member name="P:Pfz.ExceptionAwareStream.DisposeLock">
            <summary>
            Gets the lock that should be used by the object.
            </summary>
        </member>
        <member name="P:Pfz.ExceptionAwareStream.DisposeException">
            <summary>
            Gets the exception that caused the Dispose, if any.
            </summary>
        </member>
        <member name="P:Pfz.ExceptionAwareStream.WasDisposed">
            <summary>
            Gets a value indicating if this object was already disposed.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzAttributeExtensions">
            <summary>
            Adds some useful methods to the MemberInfo and Type types to
            work easily with attributes (Generics).
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttributes``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attributes of the specified type, and return them typed.
            </summary>
            <typeparam name="T">The type of the attribute to find and to return.</typeparam>
            <param name="memberInfo">The memberInfo where the attributes will be searched.</param>
            <returns>A typed array with the attributes found.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttributes``1(System.Type,System.Boolean)">
            <summary>
            Gets the attributes of the specified type, and return them typed.
            </summary>
            <typeparam name="T">The type of the attribute to find and to return.</typeparam>
            <param name="type">The type that can contains the attributes that will be searched.</param>
            <param name="inherit">If true search the attribute in base classes, but only if the attribute supports inheritance.</param>
            <returns>A typed array with the attributes found.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttributes``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the custom attributes of a parameterInfo, already typed.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Gets an attribute of the specified type, or null.
            This is useful when the attribute has AllowMultiple=false, but
            don't use it if the class can have more than one attribute of such
            type, as this method throws an exception when this happens.
            </summary>
            <typeparam name="T">The type of the parameter to find.</typeparam>
            <param name="memberInfo">The member info to search the attribute.</param>
            <returns>The found attribute or null.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttribute``1(System.Type,System.Boolean)">
            <summary>
            Gets an attribute of the specified type, or null.
            This is useful when the attribute has AllowMultiple=false, but
            don't use it if the class can have more than one attribute of such
            type, as this method throws an exception when this happens.
            </summary>
            <typeparam name="T">The type of the parameter to find.</typeparam>
            <param name="type">The type to search the attribute.</param>
            <param name="inherit">true to search in base classes for attributes that support inheritance.</param>
            <returns>The found attribute or null.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.GetCustomAttribute``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets a CustomAttribute set to this parameterInfo.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.ContainsCustomAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Verifies if a member contains an specific custom attribute.
            </summary>
            <typeparam name="T">The type of the attribute to check for existance.</typeparam>
            <param name="member">The member in which to find search for attribute.</param>
            <returns>true if the member constains the attribute, false otherwise.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzAttributeExtensions.ContainsCustomAttribute``1(System.Type,System.Boolean)">
            <summary>
            Verifies if a type contains an specific custom attribute.
            </summary>
            <typeparam name="T">The type of the attribute to check for existance.</typeparam>
            <param name="type">The member in which to find search for attribute.</param>
            <param name="inherit">true to search in base classes for attributes that support inheritance.</param>
            <returns>true if the member constains the attribute, false otherwise.</returns>
        </member>
        <member name="T:Pfz.Extensions.PfzCastingExtensions">
            <summary>
            Adds the DuckCast method to any object.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzCastingExtensions.DuckCast``1(System.Object,System.Object)">
            <summary>
            Returns an object that implements the given interface and redirects the compatible calls to the real
            object. For non-compatible calls, a NotSupportedException will be thrown.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzCastingExtensions.StructuralCast``1(System.Object,System.Object)">
            <summary>
            Tries to cast an object to the given interface, even if it does not actually implement it.
            This will only works if the actual object has at least compatible methods, properties and events
            needed by the interface, or will throw an exception.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzClonningExtensions">
            <summary>
            Adds some methods for clonning objects.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzClonningExtensions.TypedClone``1(``0)">
            <summary>
            Clones the source object returning the new one as the same type
            (cast) of the original.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzClonningExtensions.CheckedClone``1(``0)">
            <summary>
            Does a clone of an ICloneable&lt;T&gt;, checking if the source is null.
            If it is, returns null, instead of throwing an exception.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.ClonningExtensions.PfzCloneBySerializationExtension">
            <summary>
            Class that contains CloneBySerialization method.
            As the name says, it adds a method that allows to deep-clone objects, using a process similar
            to serialization/deserialization.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.ClonningExtensions.PfzCloneBySerializationExtension.CloneBySerialization``1(``0)">
            <summary>
            Clones an object by using a process similar to serialization/deserialization.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzDictionaryExtensions">
            <summary>
            Adds some methods to the Dictionary generic class.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzDictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets a value by its key or, if it doesn't exist, returns the default
            value for TValue.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzDictionaryExtensions.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Tries to get a value by its key. If it doesn't exist, creates a new
            one, adds it to the dicionary and returns it.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzDictionaryExtensions.AsReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Gets a read-only wrapper over this dictionary.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzDisplayNameExtensions">
            <summary>
            Adds methods to work easily with Enums.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzDisplayNameExtensions.GetDisplayName(System.Enum)">
            <summary>
            Gets the display name of an enumerated value.
            If no EnumDisplayName attribute is set, uses the default enum name.
            </summary>
            <param name="enumValue">The enum value to get the display name.</param>
            <returns>The display name.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzDisplayNameExtensions.GetDisplayName(System.Reflection.MemberInfo)">
            <summary>
            Gets the DisplayName of a member, or it's real name if it does
            not have a DisplayName.
            </summary>
            <param name="memberInfo">The member to get the display name for.</param>
            <returns>A name.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzDisplayNameExtensions.GetDisplayName(System.Reflection.PropertyInfo)">
            <summary>
            Gets the DisplayName of the given property.
            If the property does not have a display name and has the same name of its
            PropertyType, then the DisplayName of the PropertyType is used.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzDisposeExtensions">
            <summary>
            Adds methods to the IDispose interface.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzDisposeExtensions.CheckedDispose(System.IDisposable)">
            <summary>
            Disposes a disposable object if it is not null.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzEmitExtensions">
            <summary>
            Adds some methods to emit code more safely.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadNull(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a Ldnull.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadLocal(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits a Ldloc, receiving a localBuilder.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitStoreLocal(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits a Stloc, receiving a localBuilder.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadInt32(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Emits a Ldc_I4, receiving the value as parameter.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadArgument(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Emits Ldarg, receiving the index.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitNewObject(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
            <summary>
            Emits a Newobj. You must give a valid constructor.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitNewArray(System.Reflection.Emit.ILGenerator,System.Type,System.Int32)">
            <summary>
            Emits a Newarr. You must supply the elementType.
            So, for int[], pass the typeof(int).
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadField(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>
            Emits a Ldfld, and receives the FieldInfo of the field to load.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadStaticField(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>
            Emits a Ldsfld, and receives the FieldInfo of the static field to load.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitStoreField(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>
            Emits Stfld, and received the FieldInfo of the field to store.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitStoreStaticField(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>
            Emits Stfld, and received the FieldInfo of the static field to store.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitReturn(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits Ret.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.EmitLoadString(System.Reflection.Emit.ILGenerator,System.String)">
            <summary>
            Emits Ldstr. You must provide a valid string to it.
            Null is replaces by LoadNull.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.FullLoadToken(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>
            Loads a field token and calls GetFieldFromHandle.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.FullLoadToken(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Loads a Type token and calls GetTypeFromHandle.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEmitExtensions.FullLoadToken(System.Reflection.Emit.ILGenerator,System.Reflection.PropertyInfo)">
            <summary>
            Pushes the PropertyInfo to the stack.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzEventExtensions">
            <summary>
            This class adds two methods to the EventInfo class, making it possible
            to register into events in a "weak" manner. This means that the registered
            object can still be collected, also deregistering itself from the event.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEventExtensions.AddWeakEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            Adds an event-handler to an event, but still allows the target object to
            be collected.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzEventExtensions.RemoveWeakEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            Removes an event previously registered as weak.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzFastEnumeratorExtensions">
            <summary>
            Adds some methods to the IFastEnumerator, so you can do a foreach
            over it, convert it to a list or array.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzFastEnumeratorExtensions.AsFastEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a normal enumerable to a fast-enumerator.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzFastEnumeratorExtensions.AsEnumerable``1(Pfz.Collections.IFastEnumerator{``0})">
            <summary>
            Converts a fast enumerator to a custom IEnumerable (generic version).
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzFastEnumeratorExtensions.ToList``1(Pfz.Collections.IFastEnumerator{``0})">
            <summary>
            Copies all items from this enumerator to a list.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzFastEnumeratorExtensions.ToArray``1(Pfz.Collections.IFastEnumerator{``0})">
            <summary>
            Copies all items from this enumerator to an array.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzHashSetExtensions">
            <summary>
            Adds the AsReadOnly method.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzHashSetExtensions.AsReadOnly``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            Returns a read-only wrapper over this hashset.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzMethodInfoExtensions">
            <summary>
            Adds the GetParameterTypes method to the MethodInfo class.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzMethodInfoExtensions.GetParameterTypes(System.Reflection.MethodBase)">
            <summary>
            Gets an array with the parameter types of this method info.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.MonitorLockExtensions.PfzMonitorLockExtensions">
            <summary>
            Adds methods to lock any object using Monitor methods easily and
            always with time-out, so you can avoid dead-locks.
            See PfzLockConfiguration class if you want to log dead-locks.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.MonitorLockExtensions.PfzMonitorLockExtensions.TryLockWithTimeout``1(``0)">
            <summary>
            Tries to acquire a lock on the given object, using the default lock-timeout.
            In case of failure, it logs the error, but does not generates an exception. Instead, it returns
            null.
            </summary>
            <typeparam name="T">The type of class to lock.</typeparam>
            <param name="item">The item to lock.</param>
            <returns>A disposable object, so you can release the lock, or null if the lock was not acquired.</returns>
        </member>
        <member name="M:Pfz.Extensions.MonitorLockExtensions.PfzMonitorLockExtensions.TryLockWithTimeout``1(``0,System.Int32)">
            <summary>
            Tries to acquire a lock on the given object, using the given time-out.
            In case of failure, it logs the error, but does not generates an exception. Instead, it returns
            null.
            </summary>
            <typeparam name="T">The type of class to lock.</typeparam>
            <param name="item">The item to lock.</param>
            <param name="timeoutInMilliseconds">The timeout value while trying to acquire the lock.</param>
            <returns>A disposable object, so you can release the lock, or null if the lock was not acquired.</returns>
        </member>
        <member name="M:Pfz.Extensions.MonitorLockExtensions.PfzMonitorLockExtensions.Lock(System.Object)">
            <summary>
            Locks the actual object and returns a Disposable object.
            You can, then, dispose it before the end of the block is
            achieved with using, but without calling excessive exits.
            This is not abort-safe.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions">
            <summary>
            Class that has methods to convert values to and from many different
            representations.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ToString(System.UInt64,System.Byte)">
            <summary>
            Converts a value to string using the specific numericBase.
            </summary>
            <param name="value">The value to generate a string representation.</param>
            <param name="numericBase">The numericBase to use. 2 is binary, 16 is hexadecimal and so on.</param>
            <returns>An string representation of the given value using the right numericBase.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ToString(System.Int64,System.Byte)">
            <summary>
            Converts a value to string using the specific numericBase.
            </summary>
            <param name="value">The value to generate a string representation.</param>
            <param name="numericBase">The numericBase to use. 2 is binary, 16 is hexadecimal and so on.</param>
            <returns>An string representation of the given value using the right numericBase.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.TryParseUInt64(System.String,System.Byte,System.UInt64@)">
            <summary>
            Tries to converts an string into a ulong representation using an specific 
            numericBase.
            </summary>
            <param name="value">The string representation to convert to an ulong.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <param name="result">The resulting value.</param>
            <returns>true if the convertion was possible.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ParseUInt64(System.String,System.Byte)">
            <summary>
            Parses an string into an ulong using the given numericBase.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <returns>An ulong or throws an exception.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.TryParseInt64(System.String,System.Byte,System.Int64@)">
            <summary>
            Tries to converts an string into a ulong representation using an specific 
            numericBase.
            </summary>
            <param name="value">The string representation to convert to an ulong.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <param name="result">The resulting value.</param>
            <returns>true if the convertion was possible.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ParseInt64(System.String,System.Byte)">
            <summary>
            Parses an string into an ulong using the given numericBase.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <returns>An ulong or throws an exception.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ToString(System.UInt32,System.Byte)">
            <summary>
            Converts a value to string using the specific numericBase.
            </summary>
            <param name="value">The value to generate a string representation.</param>
            <param name="numericBase">The numericBase to use. 2 is binary, 16 is hexadecimal and so on.</param>
            <returns>An string representation of the given value using the right numericBase.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ToString(System.Int32,System.Byte)">
            <summary>
            Converts a value to string using the specific numericBase.
            </summary>
            <param name="value">The value to generate a string representation.</param>
            <param name="numericBase">The numericBase to use. 2 is binary, 16 is hexadecimal and so on.</param>
            <returns>An string representation of the given value using the right numericBase.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.TryParseUInt32(System.String,System.Byte,System.UInt32@)">
            <summary>
            Tries to converts an string into a uint representation using an specific 
            numericBase.
            </summary>
            <param name="value">The string representation to convert to an uint.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <param name="result">The resulting value.</param>
            <returns>true if the convertion was possible.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ParseUInt32(System.String,System.Byte)">
            <summary>
            Parses an string into an uint using the given numericBase.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <returns>An uint or throws an exception.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.TryParseInt32(System.String,System.Byte,System.Int32@)">
            <summary>
            Tries to converts an string into a uint representation using an specific 
            numericBase.
            </summary>
            <param name="value">The string representation to convert to an uint.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <param name="result">The resulting value.</param>
            <returns>true if the convertion was possible.</returns>
        </member>
        <member name="M:Pfz.Extensions.NumericConversionsExtensions.PfzNumericConversionsExtensions.ParseInt32(System.String,System.Byte)">
            <summary>
            Parses an string into an uint using the given numericBase.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="numericBase">The numericBase to use. For example, 2 is binary.</param>
            <returns>An uint or throws an exception.</returns>
        </member>
        <member name="T:Pfz.Extensions.PfzParameterInfoExtensions">
            <summary>
            Adds the GetTypes method to a parameterInfo array.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzParameterInfoExtensions.GetTypes(System.Reflection.ParameterInfo[])">
            <summary>
            Returns an arrays that contains all the parameterTypes of the parameterInfos array.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzReaderWriterLockExtensions">
            <summary>
            Adds methods to use ReaderWriterLockSlim easily,
            always with time-outs to avoid dead-locks.
            See PfzLockConfiguration class if you want to log dead-locks.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.ReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Abort-unsafe version of read-lock.
            Must be disposed to release the lock.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire a read-lock on the given object using the default timeout. 
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryReadLock(System.Threading.ReaderWriterLockSlim,System.Int32)">
            <summary>
            Tries to acquire a read-lock on the given object using the specified timeout. 
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to lock.</param>
            <param name="timeoutInMilliseconds">The timeout to try for the lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.UpgradeableLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Abort-unsafe version of upgradeable-lock.
            Must be disposed to release the lock.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryUpgradeableLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire an upgradeable lock on the given object, using the default timeout.
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to try to lock.</param>
            <returns>An disposable object to release the lock, or null if the locks fails.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryUpgradeableLock(System.Threading.ReaderWriterLockSlim,System.Int32)">
            <summary>
            Tries to acquire an upgradeable lock on the given object, using the specified timeout.
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to try to lock.</param>
            <param name="timeoutInMilliseconds">The maximum time to wait for the lock.</param>
            <returns>An disposable object to release the lock, or null if the locks fails.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.WriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Abort-unsafe version of write-lock.
            Must be disposed to release the lock.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Tries to acquire a write-lock on the given object using the default timeout.
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="M:Pfz.Extensions.PfzReaderWriterLockExtensions.TryWriteLock(System.Threading.ReaderWriterLockSlim,System.Int32)">
            <summary>
            Tries to acquire a write-lock on the given object using the specified timeout.
            If it fails, returns null.
            </summary>
            <param name="readerWriterLock">The object to lock.</param>
            <param name="timeoutInMilliseconds">The maximum time to wait for the lock.</param>
            <returns>A disposable object to release the lock, or null.</returns>
        </member>
        <member name="T:Pfz.Extensions.PfzStreamExtensions">
            <summary>
            Adds overloads to the stream Read method and adds the FullRead method,
            which will continue to read until it reads everything that was requested,
            or throws an IOException.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.Read(System.IO.Stream,System.Byte[])">
            <summary>
            Calls read using the full given buffer.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.Read(System.IO.Stream,System.Byte[],System.Int32)">
            <summary>
            Calls read using the given buffer and the initialIndex.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes all the bytes in the given buffer.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.Write(System.IO.Stream,System.Byte[],System.Int32)">
            <summary>
            Writes the bytes from the given buffer, beginning at the given beginIndex.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.FullRead(System.IO.Stream,System.Byte[])">
            <summary>
            Will read the given buffer to the end.
            Throws an exception if it's not possible to read the full buffer.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.FullRead(System.IO.Stream,System.Byte[],System.Int32)">
            <summary>
            Full reads the stream over the given buffer, but only at the given
            initialIndex. If the requested length can't be read, throws an 
            IOException.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.FullRead(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the buffer in the requested area, but throws an exception if
            can't read the full requested area.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Byte[],System.Action{System.Int32})">
            <summary>
            Copies data from one stream to another, using the given buffer for each
            operation and calling an action, if provided, to tell how the progress
            is going.
            </summary>
            <param name="sourceStream">The stream to read data from.</param>
            <param name="destinationStream">The stream to write data to.</param>
            <param name="blockBuffer">To buffer to use for read and write operations. The buffer does not need to be of the size of the streamed data, as many read/writes are done if needed.</param>
            <param name="onProgress">The action to be executed as each block is successfully copied. The value passed as parameter is the number of bytes read this time (not the total). This parameter can be null.</param>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadString(System.IO.Stream)">
            <summary>
            Reads a string written as size and utf-bytes.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadByteArray(System.IO.Stream)">
            <summary>
            Reads a byte-array that was written as size and bytes.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.WriteString(System.IO.Stream,System.String)">
            <summary>
            Writes an string as size and then utf bytes.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.WriteByteArray(System.IO.Stream,System.Byte[])">
            <summary>
            Writes an array as size and then bytes.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadByteOrThrow(System.IO.Stream)">
            <summary>
            Reads a byte or throws an exception at end of file.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadCompressedInt32(System.IO.Stream)">
            <summary>
            Reads a compressed int.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.WriteCompressedInt32(System.IO.Stream,System.Int32)">
            <summary>
            Writes a compressed int.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadBooleanArray(System.IO.Stream,System.Boolean[])">
            <summary>
            Reads a boolean array where the size is already known.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.WriteBooleanArray(System.IO.Stream,System.Boolean[])">
            <summary>
            Writes a boolean array.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.ReadNullableBooleanArray(System.IO.Stream,System.Nullable{System.Boolean}[])">
            <summary>
            Reads a nullable boolean array which known size.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzStreamExtensions.WriteNullableBooleanArray(System.IO.Stream,System.Nullable{System.Boolean}[])">
            <summary>
            Writes a nullable boolean array.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzThreadExtensions">
            <summary>
            Adds the AbortIfSafe and an Abort overload, which will use AbortIfSafe.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzThreadExtensions.AbortIfSafe(System.Threading.Thread,Pfz.Threading.SafeAbortMode,System.Object)">
            <summary>
            Aborts a thread only if it is safe to do so (the thread is not constructing an IDisposable object).
            It may still be useful to force a full-collection to deallocate any full-constructed but not assigned disposable object.
            Returns if the Thread.Abort() was called or not.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzThreadExtensions.Abort(System.Threading.Thread,System.Int32,System.Int32,System.Int32,System.Boolean,System.Object)">
            <summary>
            Aborts a thread, trying to use the safest abort mode, until the unsafest one.
            The number of retries is also the expected number of milliseconds trying to abort.
            </summary>
        </member>
        <member name="T:Pfz.Extensions.PfzTypeExtensions">
            <summary>
            Adds some methods to the Type class so you can discover the
            sub-types easily.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetDirectSubClasses(System.Type,System.Reflection.Assembly)">
            <summary>
            Gets the sub-classes of the specific type, in the specific assembly.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetSubClassesRecursive(System.Type,System.Reflection.Assembly)">
            <summary>
            Gets the sub-classes of the specific type, in the specific assembly.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetOrderedInterfaces(System.Type)">
            <summary>
            Gets the interfaces from this type ordered from the most "new" to the most
            "old" in the base types. Note that 2 or more interfaces added at the same
            "level" will not have an specific order.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetInterfaceProperties(System.Type)">
            <summary>
            If this type is an interface, gets all the properties from this
            it's base interfaces to this interface.
            If this is not an interface, uses the custom GetProperty.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.TryGetInterfaceProperty(System.Type,System.String)">
            <summary>
            Tries to get a property by it's name.
            If this is an interface, it also looks all the base interfaces to find
            the property.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetInterfaceProperty(System.Type,System.String)">
            <summary>
            Gets a property by it's name.
            If this type is an interface, search in it's base interfaces.
            Throws an exception if no such property is found.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetFinalInterfaces(System.Type)">
            <summary>
            Gets a reduced list of interfaces, removing Interfaces that are requisites from other interfaces already
            in the list.
            For example, an object that implemented IAdvancedDisposable must also implement IDisposable. Getting
            the list of interfaces will get both (IDisposable and IAdvancedDisposable) while this method
            will only return IAdvancedDisposable.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetCompatibleConstructor(System.Type,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Tries to get a constructor with the given parameters.
            If an exact match is not found, tries to search a compatible one.
            If acceptAConstructorCompatibleByCast is true, you can ask for a constructor(object) and
            receive a constructor(int), because with a cast that should be valid.
            If none is found, return null.
            </summary>
        </member>
        <member name="M:Pfz.Extensions.PfzTypeExtensions.GetCompatibleMethod(System.Type,System.String,System.Reflection.BindingFlags,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Tries to get a method with the given name and parameters.
            If an exact match is not found, tries to search a compatible one.
            If acceptAMethodCompatibleByCast is true, you can ask for a Method(object) and
            receive a Method(int), because with a cast that should be valid.
            If none is found, return null.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.AutoRegisterInControlFactoryAttribute">
            <summary>
            Attribute to be used in Controls types that must be registered in ControlFactory.
            This will make it register automatically if the assembly is referenced directly.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.AutoRegisterInFactoryAttributeBase">
            <summary>
            The base interface used by AutoRegisterInEditorFactory, AutoRegisterInSearcherFactory and
            so on.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.AutoRegisterInFactoryAttributeBase.#ctor(System.Type,System.Boolean)">
            <summary>
            Instantiates a new AutoRegisterInFactoryAttributeBase setting its parameters.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInFactoryAttributeBase.BaseFactoryType">
            <summary>
            Gets the base interface type of the factory.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInFactoryAttributeBase.DataType">
            <summary>
            Gets the DataType to which the factored control/editor/searcher will be able to work.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInFactoryAttributeBase.CanBeUsedForSubDataTypes">
            <summary>
            Gets a value indicating if the editor/searcher/control will be able to handle sub-types
            of DataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.AutoRegisterInControlFactoryAttribute.#ctor(System.Type,System.Boolean)">
            <summary>
            Instantiates this Attribute, telling if it can be used for sub-types or not.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInControlFactoryAttribute.BaseFactoryType">
            <summary>
            Returns typeof(IValueControl).
            </summary>
        </member>
        <member name="T:Pfz.Factoring.AutoRegisterInEditorFactoryAttribute">
            <summary>
            Attribute to be used in Controls types that must be registered in ControlFactory.
            This will make it register automatically if the assembly is referenced directly.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.AutoRegisterInEditorFactoryAttribute.#ctor(System.Type,System.Boolean)">
            <summary>
            Instantiates this Attribute, telling if it can be used for sub-types or not.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInEditorFactoryAttribute.BaseFactoryType">
            <summary>
            Returns typeof(IEditor).
            </summary>
        </member>
        <member name="T:Pfz.Factoring.AutoRegisterInFactoryAttribute">
            <summary>
            General attribute to automatically register a Type into a factory, allowing you
            to specify the base interface-factory-type to use.
            Try to use the more specific AutoRegisterIn*Factory if possible.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.AutoRegisterInFactoryAttribute.#ctor(System.Type,System.Type,System.Boolean)">
            <summary>
            Initializes a new instance of AutoRegisterInFactoryAttribute setting its parameters.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInFactoryAttribute.BaseFactoryType">
            <summary>
            Gets the interface Type that's the base for the factory.
            By this framework, it could be: IEditor, ISearcher or IControl.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.AutoRegisterInSearcherFactoryAttribute">
            <summary>
            Attribute to be used in Controls types that must be registered in SearcherFactory.
            This will make it register automatically if the assembly is referenced directly.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.AutoRegisterInSearcherFactoryAttribute.#ctor(System.Type,System.Boolean)">
            <summary>
            Instantiates this Attribute, telling if it can be used for sub-types or not.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.AutoRegisterInSearcherFactoryAttribute.BaseFactoryType">
            <summary>
            Returns typeof(ISearcher).
            </summary>
        </member>
        <member name="T:Pfz.Factoring.Factories">
            <summary>
            Class that deals with the creation of the appropriate factory for the given factoryResultType (or base factory type).
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories.Get(System.Type)">
            <summary>
            Creates a new factory prepared to create instances of the given factoryResultType.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.Factories`1">
            <summary>
            Class that manages the factories. In it, you can register the types that will be returned for given data-types, or create specialized 
            factories for datat-types.
            </summary>
            <typeparam name="T">The type of the objects that will be created by this factory.</typeparam>
        </member>
        <member name="F:Pfz.Factoring.Factories`1.Instance">
            <summary>
            Gets an Instance for this Factory. Useful only if you want to use this by interfaces.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.Register(System.Type,System.Type,System.Boolean)">
            <summary>
            Registers a type to be created for the given datatype.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.Unregister(System.Type)">
            <summary>
            Tries to register a factory for the given dataType.
            This will not unregister editors for parent dataTypes capable of editing sub-types.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.CanCreate(System.Type)">
            <summary>
            Gets a value indicating if a factory for the given dataType can be created.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.TryCreateFactory``1">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.TryCreateFactory(System.Type)">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.CreateFactory``1">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factories`1.CreateFactory(System.Type)">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IFactories`1">
            <summary>
            Typed version of IFactories.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IFactories">
            <summary>
            Interface used by factory generators, or factory of factories.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories.TryCreateFactory(System.Type)">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories.CreateFactory(System.Type)">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories.TryCreateFactory``1">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories.CreateFactory``1">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories`1.TryCreateFactory(System.Type)">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories`1.CreateFactory(System.Type)">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories`1.TryCreateFactory``1">
            <summary>
            Tries to create a factory for the given dataType.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactories`1.CreateFactory``1">
            <summary>
            Create a factory for the given dataType or throws an exception.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.Factory`2">
            <summary>
            A factory that results objects of type T that was created for the data-type TData.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IFactory`1">
            <summary>
            Typed version of IFactory.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IFactory">
            <summary>
            Interface used to access a factory without knowing its details.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactory.Create">
            <summary>
            Creates the appropriate editor/searcher for the data-type.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IFactory.FactoryBaseType">
            <summary>
            Gets the base type of the factory.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IFactory.BaseDataType">
            <summary>
            Gets the BaseDataType to which this factory is prepared to work for.
            For example, a factory registered to any object may have an actual datatype of String, but its
            base data type will still be object.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IFactory.DataType">
            <summary>
            Gets the DataType that instances created by this factory are prepared to deal with.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IFactory`1.Create">
            <summary>
            Creates the appropriate editor/searcher for the data-type.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.Factory`2.Create">
            <summary>
            Creates a new object of type T, prepared to deal with objects of type TData.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.Factory`2.BaseDataType">
            <summary>
            Gets the BaseDataType of this factory. This may be different from DataType if the registered
            object supports working with sub-types of its base data type.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.FactoryBaseAttribute">
            <summary>
            Attribute that must be used in interfaces that are meant to be the "bases" for common objects
            created by a factory.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IEditor">
            <summary>
            Interface that must be implemented by data editors.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IEditor.ApplyChanges">
            <summary>
            Requests the editor to apply all the actual updates to the record and then return it.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IEditor.Record">
            <summary>
            Gets or sets the actual record for this editor. Note that the actual record may not reflect all fields
            filled by the user. This record must be editable (not-read-only).
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IHasPreferredDataType">
            <summary>
            Interface that must be implemented by IDataControls that support many
            Value types to tell which one to use as the "default" type.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IHasPreferredDataType.PreferredDataType">
            <summary>
            Gets or sets the type of the data used by default by the
            IValueContainer.Value property.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IRecordCreator">
            <summary>
            Interface used (generally by ISearchers) to tell that they are also capable of creating new records.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IRecordCreator.CreateRecord">
            <summary>
            Creates a new record.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.ISearcher">
            <summary>
            Interface that must be implemented by "Searchers" or "Lookups".
            </summary>
        </member>
        <member name="M:Pfz.Factoring.ISearcher.FillDefaultParameters(System.Object)">
            <summary>
            Fills the default parameters (if any) to be used by this searcher.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Pfz.Factoring.ISearcher.GetResults">
            <summary>
            Gets a collection with all the results found by this searcher.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.ISearcher.MustAllowMultiSelect">
            <summary>
            Gets or sets a value indicating if this searcher allows multi-select.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.IValueControl">
            <summary>
            Interface used by controls that hold some data.
            They usually also implement at least one version of the IValueContainer
            generic interface.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.IValueControl.Clear">
            <summary>
            Clears the value of the control.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.IValueControl.IsReadOnly">
            <summary>
            Gets or sets a value telling that the control should be read-only.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.ResultSetter">
            <summary>
            Class used to set results in an unbound way.
            Initially used by Searchers and Editors.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.ResultSetter.#ctor(System.Action{System.Object})">
            <summary>
            Creates a new ResultSetter instance, telling the action to do when a new result is set.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.ResultSetter.Dispose">
            <summary>
            Restores the old result-setter.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.ResultSetter.TrySetResult(System.Object)">
            <summary>
            Tries to set a result using the last setter registered.
            Returns false if none is registered.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.ResultSetter.SetResult(System.Object)">
            <summary>
            Sets the Result using the last registered setter.
            Throws an InvalidOperationException if there is no setter registered.
            </summary>
        </member>
        <member name="T:Pfz.Factoring.TypeDictionary`1">
            <summary>
            This class is a special dictionary for types, which can also 
            search values that are set for base types or interfaces.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.Clear">
            <summary>
            Clears all items in this dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.Remove(System.Type)">
            <summary>
            Removes a value for a type.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.Set(System.Type,`0,System.Boolean)">
            <summary>
            Sets a value for the given type.
            Register is as exact match or not by the boolean value.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.SetAsExactMatch(System.Type,`0)">
            <summary>
            Set the value for a given type, but consider the type only as exact match,
            so it will not be found as a base type in FindUp.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.SetAsInheritable(System.Type,`0)">
            <summary>
            Sets the value for a given type, and tells that such value can be
            used by sub-types if one more appropriate is not found.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.FindUpOrDefault(System.Type)">
            <summary>
            Finds a value for the actual type or for a parent type.
            Returns the default value if nothing is found.
            </summary>
        </member>
        <member name="M:Pfz.Factoring.TypeDictionary`1.TryFindUp(System.Type,`0@)">
            <summary>
            Tries to find the value for the actual type or for a parent type.
            Returns true if the value is found, false otherwise.
            </summary>
        </member>
        <member name="P:Pfz.Factoring.TypeDictionary`1.Item(System.Type)">
            <summary>
            Gets a value for a type, without doing a "search".
            </summary>
        </member>
        <member name="T:Pfz.ReferenceComparer">
            <summary>
            Class used to compare two references.
            They must point to the same instance (not an equal instance) to be
            considered equal.
            </summary>
        </member>
        <member name="F:Pfz.ReferenceComparer.Instance">
            <summary>
            Gets the ReferenceComparer single instance.
            </summary>
        </member>
        <member name="T:Pfz.ReflectionHelper">
            <summary>
            This class allows you to get members from types more safely than using
            string literals. It only exists because C# does not have fieldinfoof,
            propertyinfoof and methodinfoof.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets a member by it's expression usage.
            For example, GetMember(() => obj.GetType()) will return the
            GetType method.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the constructor info from a sample construction call expression.
            Example: GetConstructor(() => new Control()) will return the constructor
            info for the default constructor of Control.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetField``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets a field from a sample usage.
            Example: GetField(() => Type.EmptyTypes) will return the FieldInfo of
            EmptyTypes.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetProperty``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets a property from a sample usage.
            Example: GetProperty(() => str.Length) will return the property info 
            of Length.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetMethod(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Gets a method info of a void method.
            Example: GetMethod(() => Console.WriteLine("")); will return the
            MethodInfo of WriteLine that receives a single argument.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper.GetMethod``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the MethodInfo of a method that returns a value.
            Example: GetMethod(() => Console.ReadLine()); will return the method info
            of ReadLine.
            </summary>
        </member>
        <member name="T:Pfz.ReflectionHelper`1">
            <summary>
            This is a typed version of reflection helper, so your expression already starts with a know
            object type (used when you don't have an already instantiated object).
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper`1.GetMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Gets a member by it's expression usage.
            For example, GetMember((obj) => obj.GetType()) will return the
            GetType method.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper`1.GetField``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Gets a field from a sample usage.
            Example: GetField((obj) => obj.SomeField) will return the FieldInfo of
            EmptyTypes.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Gets a property from a sample usage.
            Example: GetProperty((str) => str.Length) will return the property info 
            of Length.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper`1.GetMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Gets a method info of a void method.
            Example: GetMethod((obj) => obj.SomeCall("")); will return the
            MethodInfo of SomeCall that receives a single argument.
            </summary>
        </member>
        <member name="M:Pfz.ReflectionHelper`1.GetMethod``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Gets the MethodInfo of a method that returns a value.
            Example: GetMethod((obj) => obj.SomeCall()); will return the method info
            of SomeCall.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.AllowSyncRemoting">
            <summary>
            Allows changing if the actual thread allows sync remoting or if the default must be used.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.AllowSyncRemoting.#ctor(System.Nullable{System.Boolean})">
            <summary>
            Changes the value of AllowSyncRemoting. Use it in a using clause, so it is reversible.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.AllowSyncRemoting.Dispose">
            <summary>
            Restores the old value.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.AllowSyncRemoting.Value">
            <summary>
            Gets or sets a value indicating if the actual thread allows synchronous remoting.
            A null value means the AllowSyncCalls from the RemotingClient will be used.
            You may prefer instancing this class if you want the change to be reversible.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.BufferedWriteStream">
            <summary>
            This class provides buffered write operations, but non-buffered read operations.
            For TCP/IP operations with NoDelay set to true, it will be bettern than using a normal BufferedStream, because
            you can do reads and writes at the same time (which causes errors in BufferedStream class, as the buffer is shared)
            and will also be faster, as TCP/IP already has a read buffer. In fact, this class is only needed because
            there is no way to control TCP/IP to only send its buffered bytes by a "flush" command.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new BufferedStream over the given baseStream and with the specified bufferSize.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.Dispose(System.Boolean)">
            <summary>
            Disposes the baseStream and nullifies the buffer.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.Flush">
            <summary>
            Flushes any pending write and also calls the BaseStream.Flush.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Redirects the call to BaseStream.Read.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.SetLength(System.Int64)">
            <summary>
            Calls the BaseStream.SetLength, but this is likely to throw an exception.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.BufferedWriteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Tries to buffer a write. If the buffer is filled or if the data to be sent is greater than the buffer,
            Flushes this object, and writes the new data directly.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.BaseStream">
            <summary>
            Gets the BaseStream to which the data will be written.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.BufferSize">
            <summary>
            Gets or sets the BufferSize used by this BufferedWriteStream.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.CanRead">
            <summary>
            Gets the BaseStream.CanRead.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.CanWrite">
            <summary>
            Gets the BaseStream.CanWrite.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.Length">
            <summary>
            Gets the BaseStream.Length, but this is likely to throw an exception.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.Position">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.CanTimeout">
            <summary>
            Returns BaseStream.CanTimeout
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.ReadTimeout">
            <summary>
            Gets or sets BaseStream.ReadTimeout
            </summary>
        </member>
        <member name="P:Pfz.Remoting.BufferedWriteStream.WriteTimeout">
            <summary>
            Gets or sets BaseStream.WriteTimeout
            </summary>
        </member>
        <member name="T:Pfz.Remoting.ChannelCreatedEventArgs">
            <summary>
            Argument passed to Channellers when a new channel is created.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.ChannelCreatedEventArgs.Channel">
            <summary>
            The created channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.ChannelCreatedEventArgs.Data">
            <summary>
            The user-data provided when creating the channel.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.CryptographySide">
            <summary>
            The cryptography side used by TcpChanneller and TcpChannellerListener.
            </summary>
        </member>
        <member name="F:Pfz.Remoting.CryptographySide.None">
            <summary>
            Does not use cryptography.
            </summary>
        </member>
        <member name="F:Pfz.Remoting.CryptographySide.Server">
            <summary>
            Starts the cryptography as the server.
            </summary>
        </member>
        <member name="F:Pfz.Remoting.CryptographySide.Client">
            <summary>
            Starts the cryptography as the client.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.DisposableTcpConnection">
            <summary>
            This class represents the Client returned by DisposableTcpListener.
            It can also be used to wrap TcpClient objects to the IClient interface.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IConnection">
            <summary>
            Interface used to make communication on the client side more generic.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IConnection.LocalEndpoint">
            <summary>
            Gets the Local endpoint as string.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IConnection.RemoteEndpoint">
            <summary>
            Gets the Remote endpoint as string.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IConnection.Stream">
            <summary>
            Gets or sets the stream used by this client.
            Only set the stream if you are decorating it, or you could cause serious bugs.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpConnection.#ctor(System.Net.Sockets.TcpClient)">
            <summary>
            Creates a new DisposableTcpClient over the given TcpClient.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpConnection.#ctor(System.String,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Creates a new DisposableTcpClient connecting to the given host and port and allowing you to
            set if tcp delay is used or not.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpConnection.Dispose">
            <summary>
            Releases the stream and internal client useds, and removes itself from the listener.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.DisposableTcpConnection.WasDisposed">
            <summary>
            Gets a value indicating if this client was disposed/disconnected.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.DisposableTcpConnection.Stream">
            <summary>
            Gets or sets the stream used to communicate.
            Even if the stream can be changed, only do that if you are decorating the original stream.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.DisposableTcpConnection.LocalEndpoint">
            <summary>
            Gets the local endpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.DisposableTcpConnection.RemoteEndpoint">
            <summary>
            Gets the remote endpoint.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.DisposableTcpListener">
            <summary>
            TcpListener that implements IAdvancedDisposable and IListener interfaces.
            It also disposes all its active connections when it is itself disposed.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IConnectionListener`1">
            <summary>
            Interface used by generic-purpose listeners.
            Such listeners requires that you configure them before calling TryAccept, but
            have a more generic approach than TcpListener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.IConnectionListener`1.TryAccept">
            <summary>
            Tries to accept a new connection or returns null if this object was disposed.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.IConnectionListener`1.GetConnections">
            <summary>
            Gets a copy of all active connections of this listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpListener.#ctor(System.Net.IPAddress,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates and configures a new DisposableTcpListener.
            </summary>
            <param name="address">The addess to listen.</param>
            <param name="port">The port to listen.</param>
            <param name="hasTcpDelay">If true, the TcpDelay (to avoid multiple small packets) is on.</param>
            <param name="bufferedWriteStreamSize">If different than -1 tells that a local BufferedWriteStream should be used by new connections.</param>
            <param name="receiveBufferSize">If different than -1 configures the Tcp Receive Buffer size.</param>
            <param name="sendBufferSize">If different than -1 configures the Tcp Send Buffer size.</param>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpListener.Dispose">
            <summary>
            Frees the internal listener and disposes all active clients.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpListener.TryAccept">
            <summary>
            Tries to accept a new connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.DisposableTcpListener.GetConnections">
            <summary>
            Gets a copy array of all connected clients.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.DisposableTcpListener.WasDisposed">
            <summary>
            Gets a value indicating if this listener was disposed.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.HybridChanneller">
            <summary>
            This is a channeller capable of connecting using MemoryMappedFiles for fast local connections, or Tcp/Ip for remote connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.HybridChanneller.Connect(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new channeller using the appropriate mode (MemoryMappedFiles or Tcp/Ip).
            </summary>
        </member>
        <member name="T:Pfz.Remoting.HybridChannellerListener">
            <summary>
            This is a listener that uses MemoryMappedFiles for local communication and
            Tcp/Ip for remote communications.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IChannellerListener">
            <summary>
            Interface that must be implemented by "listeners" that accept "channellers".
            That is: A listener accepts a new connection. Then, many channels can be created in the same connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.IChannellerListener.TryAccept">
            <summary>
            Accepts a new connection or returns null if the connection is closed.
            May still throw exceptions for other reasons.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.HybridChannellerListener.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new HibrydChanneller on the given port and using the given bufferLengths.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.HybridChannellerListener.Dispose(System.Boolean)">
            <summary>
            Releases the Tcp/Ip and MemoryMappedFile listeners.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.HybridChannellerListener.TryAccept">
            <summary>
            Accepts a new channel, be it local or remote.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IChannel">
            <summary>
            Interface that represents a channel of communication.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChannel.Channeller">
            <summary>
            Gets the channeller that created this channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChannel.LocalEndpoint">
            <summary>
            Gets the LocalEndPoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChannel.RemoteEndpoint">
            <summary>
            Gets the RemoteEndPoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChannel.Stream">
            <summary>
            Gets the stream used for communication.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IChanneller">
            <summary>
            Interface that must be implemented by channellers. That is, thay allow many channels to be created in a single "connection".
            </summary>
        </member>
        <member name="M:Pfz.Remoting.IChanneller.CreateChannel(System.Object)">
            <summary>
            Creates a new channel.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.IChanneller.Start">
            <summary>
            Starts this channeller.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChanneller.LocalEndpoint">
            <summary>
            Gets the LocalEndPoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.IChanneller.RemoteEndpoint">
            <summary>
            Gets the RemoteEndPoint.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.IChanneller.ChannelCreated">
            <summary>
            Event invoked when a channel is created from a remote's side request.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.IRemotable">
            <summary>
            Interface that must be implemented by Serializable objects to mark them as acessible to the remoting framework.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MemoryMappedFileReader">
            <summary>
            Creates a communication reader using MemoryMappedFiles.
            In general, using MemoryMappedFiles is faster than using NamedPipes or other means of inter-process communication.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.#ctor(System.String,System.Int32)">
            <summary>
            Creates the reader, which should connect to the given NamedPipe and, optionally, with a time-out,
            which will be only as the connection time-out.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.Dispose">
            <summary>
            Frees all the resources used by this reader and, possible, releases the MemoryMappedFile.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.ReadByte">
            <summary>
            Reads a single byte from the stream.
            May return -1 if the connection is lost, or throw a TimeoutException if no more data is being received.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.Read(System.Byte[])">
            <summary>
            Tries to fill the buffer, but will return the actual number of bytes read.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.Read(System.Byte[],System.Int32)">
            <summary>
            Tries to fill the buffer, but will return the actual number of bytes read.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Tries to fill the buffer, but will return the actual number of bytes read.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileReader.Timeout">
            <summary>
            Gets or sets the time-out of this reader.
            This is not the same as the connection time out and must be set explicity.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileReader.MemoryMappedFileLength">
            <summary>
            Gets the Length of the memory-mapped-file.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MemoryMappedFileStream">
            <summary>
            This class represents a communication stream that uses MemoryMappedFiles as its sharing resource.
            It is bidirectional
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.CreateAsServer(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new memory-mapped-file communication, as the server.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.CreateAsClient(System.String,System.Int32)">
            <summary>
            Creates a new memory-mapped-file communication, as the client.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.Dispose(System.Boolean)">
            <summary>
            Releases the reader and writer.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.Flush">
            <summary>
            Tells the other side that it can start reading.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data to the given buffer.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.SetLength(System.Int64)">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer data to the stream.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.ReadByte">
            <summary>
            Reads a single byte of data. Returns -1 if connection is lost.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte of data.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.CanTimeout">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.Name">
            <summary>
            Gets the Name of this MemoryMappedFileStream.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.ReadTimeout">
            <summary>
            Gets or sets the read-timeout.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.WriteTimeout">
            <summary>
            Gets or sets the write-timeout.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.Length">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileStream.Position">
            <summary>
            Not supported.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MemoryMappedFileWriter">
            <summary>
            This class represents a communication stream based on MemoryMappedFiles. It only works locally, but
            is faster than TCP/IP or NamedPipes.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new MemoryMappedFileWriter with the given name and length, and optionally with the given
            timeout, which will be the time it will wait for client connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.Dispose">
            <summary>
            Releases all resources used by this Memory-Mapped-File.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.Write(System.Byte[])">
            <summary>
            Writes the buffer data.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the buffer data.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer data.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.Flush">
            <summary>
            Tells the other side that it can start reading.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MemoryMappedFileWriter.WriteByte(System.Byte)">
            <summary>
            Writes a single byte of data.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileWriter.Timeout">
            <summary>
            Gets or sets the time-out used for writes.
            This is not the same as the connection time out and must be set explicity.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MemoryMappedFileWriter.MemoryMappedFileLength">
            <summary>
            Gets the Length of the memory-mapped-file.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MmfChannel">
            <summary>
            Represents a channel that uses MemoryMappedFiles for communication.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChannel.Dispose(System.Boolean)">
            <summary>
            Releases all the resources used by this channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MmfChannel.Channeller">
            <summary>
            Gets the Channeller that controls this channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MmfChannel.Stream">
            <summary>
            Gets the Stream of this channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MmfChannel.Name">
            <summary>
            Gets the MemoryMappedFileName
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MmfChanneller">
            <summary>
            Creates a Channeller (multi-channel support) using MemoryMappedFiles.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChanneller.#ctor(System.Int64,System.Boolean)">
            <summary>
            Creates a new MemoryMappedFile channeller with the given id, and running as a client or server. In this case, it is not bound
            to a listener, and you must provide a unique id (probably using TicksOrIncrement.GetValue().
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChanneller.#ctor(System.String)">
            <summary>
            Creates a new channeller that will try to connect to the given listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChanneller.Dispose(System.Boolean)">
            <summary>
            Frees the resources (memory mapped files, mutexes and so on) used by this channeller.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChanneller.CreateChannel(System.Object)">
            <summary>
            Creates a new channel for communication.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChanneller.Start">
            <summary>
            Starts this channeller.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.MmfChanneller.ChannelBufferLength">
            <summary>
            Gets or sets the channel buffer length.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.MmfChanneller.ChannelCreated">
            <summary>
            Event invoked when a new channel is created from the remote side.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.MmfChannellerListener">
            <summary>
            Creates a Listener using MemoryMappedFiles (local-only, but very fast).
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChannellerListener.#ctor(System.String)">
            <summary>
            Creates a new listener with the given name.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChannellerListener.Dispose(System.Boolean)">
            <summary>
            Releases all the resources used by this object.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.MmfChannellerListener.TryAccept">
            <summary>
            Tries to accept a new channeller.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Pfz.Threading.IRunnable">
            <summary>
            Interface used by objects capable of "Running".
            In threading scenarios, it is usually better to run a Runnable, with is rightly typed in its execution
            and must have all fields/properties set than to use Actions and possible unnamed delegates, which
            can use volatile data and, for threads, may be at corrupt states.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IRunnable.Run">
            <summary>
            Runs this object.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingClient">
            <summary>
            Class used to access objects remotelly.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingCommon">
            <summary>
            This class has the common parameters used by the RemotingClient and RemotingServer classes.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.CheckThread">
            <summary>
            Checks if the method is being called by the Thread that created this object.
            If not, throws a RemotingException.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.CheckModifiable">
            <summary>
            Checks if the the parameters are still modifiable..
            If not, throws a RemotingException.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterType``2">
            <summary>
            Registers an interface by it's default name and the class that will implement it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterType(System.String,System.Reflection.ConstructorInfo)">
            <summary>
            Registers an object constructor and gives a name to it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterType``1(System.String,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Registers an object constructor, found by an expression, and gives a name to it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod(System.String,System.Reflection.MethodInfo)">
            <summary>
            Registers an static method and gives a name to find it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod``1(System.String,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Registers an static method by a call expression and gives a name to it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod``1(System.String,System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Registers an static method by a call expression and gives a name to it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod(System.Reflection.MethodInfo)">
            <summary>
            Registers an static method by its own name.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Registers an static method found by an expression and uses its own name.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingCommon.RegisterStaticMethod(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Registers an static method found by an expression and uses its own name.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.DefaultBufferSizePerChannel">
            <summary>
            Gets or sets the DefaultBufferSize used by every channel of communication.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.AllowSyncCalls">
            <summary>
            Gets or sets a value indicating if this Remoting object allows sync calls.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingCommon.UserChannelCreated">
            <summary>
            Event invoked when a call to CreateUserChannel is done in the remove side.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokeMethodEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote method.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokePropertyGetEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote property get.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokePropertySetEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote property set.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokeEventAddEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote event add.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokeEventRemoveEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote event remove.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingCommon.InvokeDelegateEvents">
            <summary>
            Gets that can be raised before or after effectivelly invoking a local or remote delegate.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.#ctor">
            <summary>
            Creates a new RemotingClient.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.#ctor(Pfz.Remoting.RemotingParameters)">
            <summary>
            Creates a new RemotingClient with the given parameters
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Dispose(System.Boolean)">
            <summary>
            Frees the unmanaged resources of this RemotingClient.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.GetFromRemoteObject(System.Object)">
            <summary>
            Gets the RemotingClient that created the given remote object.
            Returns null if the object is not remote.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Start(Pfz.Remoting.IChanneller)">
            <summary>
            Starts this remoting client.
            Parameters will not accept changes anymore.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Start(System.String,System.Int32)">
            <summary>
            Starts this RemotingClient.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Disconnect">
            <summary>
            Disconnects the active connection.
            This may end-up disposing the RemotingClient if it does not supports reconnections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.CreateUserChannel(System.Object)">
            <summary>
            Creates an stream to communicate to the other side, without opening a new tcp ip port.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.InvokeStaticMethod(System.String,System.Object[])">
            <summary>
            Invokes a registered static method on the other side.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Create(System.String,System.Object[])">
            <summary>
            Creates a registered object on the other side.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingClient.Create``1">
            <summary>
            Creates an interface registered on the other side, using its default name and constructor.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingClient.ExecutingClient">
            <summary>
            Gets the RemotingClient that invoked the actual method, directly or indirectly.
            Will return null if the actual method was not invoked by a remote call.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingClient.Channeller">
            <summary>
            Gets the channeller used by this remoting client.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingClient.IsStarted">
            <summary>
            Gets a value indicating if Start was already called or not.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingClient.RunnableRunner">
            <summary>
            Gets a runnable runner (dispatcher, if you prefer) to send messages to this client.
            Use it when executing asynchronous calls, so a slow client will not hang the server.
            Do not use ThreadPool threads or Tasks to send async messages to the clients, as 
            eventually all threads will be occupied to respond to the slowest client.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingClient.Disposed">
            <summary>
            Event invoked when this RemotingClient is disposed.
            To guarantee that it will be invoked, set this event in the RemotingClientParameters before
            creating it.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingClientConnectedEventArgs">
            <summary>
            Argument used by RemotingServer.ClientConnected event.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.RemotingClientConnectedEventArgs.Client">
            <summary>
            Gets the Client that just connected.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingEventGroup`1">
            <summary>
            This class contains the BeforeInvoke, AfterInvoke, BeforeRedirect and AfterRedirect events,
            which can be invoked by the remoting framework when invoking locak (BeforeInvoke, AfterInvoke)
            or when redirecting a call to a remove object (BeforeRedirect, AfterRedirect).
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingEventGroup`1.Clone">
            <summary>
            Clones the actual RemotingEventGroup object.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingEventGroup`1.BeforeInvoke">
            <summary>
            Event invoked when a remote call finished in the invocation of a local object.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingEventGroup`1.AfterInvoke">
            <summary>
            Event invoked when a remote call finished in the invocation of a local object.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingEventGroup`1.BeforeRedirect">
            <summary>
            Event invoked when a local call is being redirected to a remote object.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingEventGroup`1.AfterRedirect">
            <summary>
            Event invoked when a local call was redirected to a remote object.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingException">
            <summary>
            Exception thrown by the remoting framework when something wrong happens.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingException.#ctor">
            <summary>
            Only following the Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingException.#ctor(System.String)">
            <summary>
            Only following the Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingException.#ctor(System.String,System.Exception)">
            <summary>
            Only following the Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Only following the Exception pattern.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingParameters">
            <summary>
            This class has the common parameters used by the RemotingClient and RemotingServer classes.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingServer">
            <summary>
            Class that acts as a server to remoting connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.#ctor(Pfz.Remoting.IChannellerListener)">
            <summary>
            Creates the server using the given parameters.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.#ctor(System.Int32)">
            <summary>
            Creates a new RemotingServer object, that will listen at the given tcp/ip port.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.Dispose(System.Boolean)">
            <summary>
            Closes the server connection and all client connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.Start">
            <summary>
            Starts the server and makes its parameters read-only.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.CreateClient(Pfz.Remoting.RemotingParameters)">
            <summary>
            Executed when a client connects, so a "RemotingClient" object must be created.
            This method is here in case you need to return a more specific remoting client.
            
            You must create the RemotingClient using the version that receives the the "parameters".
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingServer.GetConnectedClients">
            <summary>
            Gets an array with all connected clients.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.RemotingServer.ClientConnected">
            <summary>
            Event invoked when just after a client connects.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.RemotingSyncException">
            <summary>
            Exception thrown by a RemotingClient when trying to do a synchronous remoting call by
            a remoting client that does not allow such calls.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingSyncException.#ctor">
            <summary>
            Pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingSyncException.#ctor(System.String)">
            <summary>
            Pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingSyncException.#ctor(System.String,System.Exception)">
            <summary>
            Pattern.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.RemotingSyncException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Pattern.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.SecureStream">
            <summary>
            This is a class that transforms a simple (non-encrypted) stream into an
            encrypted one. <br/>
            It does: Create an assymetric private key (on server), sends the public
            part to the client and, then, the client creates a new symmetric key that 
            is known is sent to the server using the asmmetric key.<br/>
            After that, only the symmetric algorithm is used, as it is faster,
            but it is guaranteed that only the server and the client knows the key.<br/>
            This cryptography guarantees that no one "sniffing" the network would be
            able to interpret the messages, but does not guarantees that the requested
            host is really the host it should be. To that additional verification,
            you would probably need to deal with certificates and the SslStream.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream, without any other parameters, so, running as client.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream, specifying if running as client or server, but without changing
            the default symmetric or assymetric class/algorithm..
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream. <br/>
            Species the symmetricAlgorithm to use.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream,System.Security.Cryptography.SymmetricAlgorithm,System.Boolean)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream. <br/>
            Species the symmetricAlgorithm to use and if it runs as a client or server.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream,System.Security.Cryptography.RSACryptoServiceProvider,System.Security.Cryptography.SymmetricAlgorithm,System.Boolean)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream. <br/>
            Specifies the assymetric and the symmetric algorithm to use, and if it 
            must run as client or server.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.#ctor(System.IO.Stream,System.Security.Cryptography.RSACryptoServiceProvider,System.Security.Cryptography.SymmetricAlgorithm,System.Boolean,System.Int32)">
            <summary>
            Creates a new secure stream (stream that uses an assymetric key to
            initialize and then a symmetric key to continue it's work) over another
            stream. <br/>
            Specifies the assymetric and the symmetric algorithm to use, if it 
            must run as client or server and the writeBufferInitialLength.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.Dispose(System.Boolean)">
            <summary>
            Releases the buffers, the basestream and the cryptographic classes.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads and decryptographs the given number of bytes from the buffer.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypts and writes the given bytes.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.Flush">
            <summary>
            Sends all the buffered data.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.SecureStream.SetLength(System.Int64)">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.BaseStream">
            <summary>
            Gets the original stream that created this asymmetric crypto stream.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.SymmetricAlgorithm">
            <summary>
            Gets the symmetric algorithm being used.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.Decryptor">
            <summary>
            Gets the encryptor being used.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.Encryptor">
            <summary>
            Gets the decryptor being used.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.Length">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.Position">
            <summary>
            Throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.ReadTimeout">
            <summary>
            Gets or sets the time-out for reads.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.WriteTimeout">
            <summary>
            Gets or sets the time-out for writes.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.SecureStream.CanTimeout">
            <summary>
            Gets a value indicating if this stream supports timed-out operations.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.StreamChannel">
            <summary>
            Represents a "Channel" inside a StreamChanneller. This is used by the remoting
            mechanism to separate each thread communication channel inside a single tcp/ip
            connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.OnDispose(System.Boolean)">
            <summary>
            Frees all needed resources and informs the remote side.
            </summary>
            <param name="disposing">True if called from Dispose()</param>
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.Flush">
            <summary>
            Sends all buffered data to the stream.
            </summary>
            
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the channel.
            </summary>
            <param name="buffer">The buffer to store the read data.</param>
            <param name="offset">The initial position to store data in the buffer.</param>
            <param name="count">The number of bytes expected to read.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes into this channel.
            </summary>
            <param name="buffer">The buffer to get bytes to write.</param>
            <param name="offset">The initial position in the buffer to send.</param>
            <param name="count">The number of bytes from the buffer to send.</param>
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Method from Stream. Throws a NotSupportedException.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.StreamChannel.SetLength(System.Int64)">
            <summary>
            Method from Stream. Throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.LocalEndpoint">
            <summary>
            Gets the LocalEndpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.RemoteEndpoint">
            <summary>
            Gets the RemoteEndpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.Id">
            <summary>
            Gets the Id given to this channel locally.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.RemoteId">
            <summary>
            Gets the Id given to this channel by the remote host.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.Channeller">
            <summary>
            Gets the channeller to which this channel belongs to.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.Length">
            <summary>
            Property from Stream. Always returns -1.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.Position">
            <summary>
            Property from Stream. Always returns -1 and throws a NotSupportedException
            if set.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.CanRead">
            <summary>
            Property from Stream. Always return true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.CanSeek">
            <summary>
            Property from Stream. Always return false.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.CanWrite">
            <summary>
            Property from Stream. Always return true.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.CanTimeout">
            <summary>
            Returns the base.CanTimeout
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.ReadTimeout">
            <summary>
            Gets or sets the read-timout of this channel.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChannel.WriteTimeout">
            <summary>
            Gets or sets the write-timout of this channel.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.StreamChanneller">
            <summary>
            Class responsible for creating many channels inside another stream.
            This is used by the remoting framework, so each thread has it's own
            channel inside a single tcp/ip connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.StreamChanneller.#ctor(System.IO.Stream,System.Int32,System.String,System.String)">
            <summary>
            Creates the channeller for the specified stream and allows you to
            specify the buffer size. For tcp/ip stream, use the bigger value
            between receive an send buffer size.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.StreamChanneller.Start">
            <summary>
            Starts this channeller.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.StreamChanneller.Dispose(System.Boolean)">
            <summary>
            Disposes the channeller and the stream.
            </summary>
            <param name="disposing">true if called from Dispose() and false if called from destructor.</param>
        </member>
        <member name="M:Pfz.Remoting.StreamChanneller.CreateChannel(System.Object)">
            <summary>
            Creates a channel, sending the serializableData parameter to the
            other side, so it can decide what to do with this channel before it
            gets used (this avoids an extra tcp/ip packet for small information).
            </summary>
            <param name="serializableData">Data to send to the other side.</param>
            <returns>A new channel.</returns>
        </member>
        <member name="P:Pfz.Remoting.StreamChanneller.LocalEndpoint">
            <summary>
            Gets the LocalEndpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.StreamChanneller.RemoteEndpoint">
            <summary>
            Gets the RemoteEndpoint.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.StreamChanneller.Disposed">
            <summary>
            Event called when Dispose() has just finished.
            </summary>
        </member>
        <member name="E:Pfz.Remoting.StreamChanneller.ChannelCreated">
            <summary>
            Event that is invoked when the remote side creates a new channel.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.ChannellerConnection">
            <summary>
            Channeller for tcp/ip connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerConnection.Create(System.Net.Sockets.TcpClient,System.Int32,Pfz.Remoting.CryptographySide)">
            <summary>
            Creates a new channeller over the given tcp/ip client.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerConnection.Create(Pfz.Remoting.IConnection,System.Int32,Pfz.Remoting.CryptographySide)">
            <summary>
            Creates a new channeller connection over an existing connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerConnection.Dispose(System.Boolean)">
            <summary>
            Releases all resources.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.ChannellerListener">
            <summary>
            Listener for Tcp/IP connections and channellers.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerListener.#ctor(System.Net.IPAddress,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new listener on the given address, port and using the given bufferSizePerChannel.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerListener.#ctor(Pfz.Remoting.IConnectionListener{Pfz.Remoting.IConnection},System.Int32,System.Boolean)">
            <summary>
            Creates a new channeller listener over an existing Listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerListener.Dispose(System.Boolean)">
            <summary>
            Releases the internal listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.ChannellerListener.TryAccept">
            <summary>
            Accepts a new channeller.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.GuaranteedUdpConnection">
            <summary>
            An UDP connection that supports guaranteed delivery. It is not ordered, so it does not replaces the Tcp/IP.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.IGuaranteedUdpConnection">
            <summary>
            Interface that must be implemented by custom connection that also offer
            asynchronous datagram sends/receives.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.IUdpConnection">
            <summary>
            Interface that must be implemented by drivers that support Udp message communication.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IUdpConnection.UdpSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends an udp packet.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IUdpConnection.UdpReceive">
            <summary>
            Receives a datagram packet.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.IUdpConnection.UdpHeaderSize">
            <summary>
            Gets the header size present in all received packets.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IGuaranteedUdpConnection.IsGuaranteedPacket(System.Byte[])">
            <summary>
            Checks if a packet was sent as guaranteed or not.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IGuaranteedUdpConnection.GuaranteedSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Similar to UdpSend, but the packet is guaranteed to arrive.
            The only problem is that it is unordered.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of this class.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.#ctor(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Creates a new instance of this class.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.Dispose(System.Boolean)">
            <summary>
            Releases all resources used by this UDP connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.UdpReceive">
            <summary>
            Receives an UDP packet. Note that it includes a header used by the framework, so
            check the UdpHeaderSize property.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.GuaranteedSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends a guaranteed to arrive packet. It is still unordered.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.UdpSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends an udp packet. Note that if you are using guaranteed sends you should not use the udp object to send,
            you must send udp packets by this method.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpConnection.IsGuaranteedPacket(System.Byte[])">
            <summary>
            Checks if a packet was sent as guaranteed (true) or not.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.GuaranteedUdpConnection.RemoteEndpoint">
            <summary>
            Gets information about the RemoteEndpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.GuaranteedUdpConnection.UdpHeaderSize">
            <summary>
            Gets the size of the Header information put in all packets.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.GuaranteedUdpListener">
            <summary>
            A listener of TcpWithUdpConnections.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.IUdpConnectionListener`1">
            <summary>
            Interface used by generic-purpose listeners.
            Such listeners requires that you configure them before calling TryAccept, but
            have a more generic approach than TcpListener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IUdpConnectionListener`1.TryAccept">
            <summary>
            Tries to accept a new connection or returns null if this object was disposed.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.IUdpConnectionListener`1.GetConnections">
            <summary>
            Enumerates all active connections of this listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpListener.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of this class, setting the port to listen to and the number of Udp packets that must be sent before
            waiting for a confirmation.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpListener.Dispose(System.Boolean)">
            <summary>
            Releases the listener.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpListener.TryAccept">
            <summary>
            Tries to accept a new connection. May return null if the listener is disposed.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.GuaranteedUdpListener.GetConnections">
            <summary>
            Gets a copy of all active connections at this moment.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.TcpWithUdpConnection">
            <summary>
            TcpIp connection that has an UDP connection bound to it, so you can opt to send guaranteed and ordered packets or
            udp (optional) packets. Also allows you to configure it so it can use a guaranteed udp version, in which case
            packets are unordered, but are guaranteed to arrive.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.#ctor(System.String,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Creates and configures a new TcpWithUdpConnection instance.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.Dispose(System.Boolean)">
            <summary>
            Releases the tcp and udp connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.UdpSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends an UDP packet. This packet can be lost.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.UdpReceive">
            <summary>
            Receives an UDP packet. Note that it may include a header, so check the UdpHeaderSize property.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.GuaranteedSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends a message with guarantee of delivery. It does not guarantees the order, however.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpConnection.IsGuaranteedPacket(System.Byte[])">
            <summary>
            Checks if a packet was sent as guaranteed (true) or not.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.TcpWithUdpConnection.LocalEndpoint">
            <summary>
            Gets the local endpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.TcpWithUdpConnection.RemoteEndpoint">
            <summary>
            Gets the remote endpoint.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.TcpWithUdpConnection.Stream">
            <summary>
            Gets or sets the stream used for the ordered (tcp/ip) communication.
            </summary>
        </member>
        <member name="P:Pfz.Remoting.Udp.TcpWithUdpConnection.UdpHeaderSize">
            <summary>
            Gets the size of the header added to all packets.
            </summary>
        </member>
        <member name="T:Pfz.Remoting.Udp.TcpWithUdpListener">
            <summary>
            This is a connection listener that accepts both a tcp/ip connection and a bound udp connection with it.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpListener.#ctor(System.Net.IPAddress,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of this listener and configures how connections will work.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpListener.Dispose(System.Boolean)">
            <summary>
            Releases this listener and all active connections.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpListener.TryAccept">
            <summary>
            Tries to accept a connection.
            </summary>
        </member>
        <member name="M:Pfz.Remoting.Udp.TcpWithUdpListener.GetConnections">
            <summary>
            Gets an array with all active connections.
            </summary>
        </member>
        <member name="T:Pfz.Serialization.BinarySerializer">
            <summary>
            A binary serializer faster and more compressed than custom .Net 
            BinaryFormatter.
            It DOES NOT take the many serialization attributes 
            and other serialization objects into account.
            </summary>
        </member>
        <member name="T:Pfz.Serialization.BinarySerializerBase">
            <summary>
            Base class for BinarySerializer and RemotingSerializer.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializerBase.AddDefaultType(System.Type)">
            <summary>
            This method adds a type to the "automatic type list".
            This avoids such type to be saved in serialized streams, but the
            deserializer must add the exactly same types, in the exactly same
            order.
            Returns a boolean value indicating if such type was added (true),
            or if was already added before (false).
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializerBase.AddPrimitivesAsDefault">
            <summary>
            Adds primitive types as Default-Types.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializerBase.AddRecommendedDefaults">
            <summary>
            Adds primitives, string, DateTime, decimal and some other common
            types as default types.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializerBase.AddDefaultTypeRecursive(System.Type)">
            <summary>
            Adds the given type to the list of default types, and every
            type referenced by this type, directly or indirectly, that is
            not a value type (as the Type for value type references are 
            never serialized).
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializerBase.AddNullableOfDefaultsAsDefaults">
            <summary>
            Add the nullable version of already added value-type defaults
            as default values.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes the given object.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.BinarySerializer.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes an object from the given stream.
            </summary>
        </member>
        <member name="P:Pfz.Serialization.BinarySerializer.Context">
            <summary>
            Gets or sets the Context used by the ISerializable interface.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.RemotingSerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes the given object.
            </summary>
        </member>
        <member name="M:Pfz.Serialization.RemotingSerializer.Deserialize(System.IO.Stream,System.Object)">
            <summary>
            Deserializes an object from the given stream.
            </summary>
        </member>
        <member name="T:Pfz.Threading.BaseDisposableThreadLocal">
            <summary>
            Base class for DiposableThreadLocal and its generic version.
            </summary>
        </member>
        <member name="M:Pfz.Threading.BaseDisposableThreadLocal.Dispose">
            <summary>
            Releases the values used by all threads that accessed this thread-local variable.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Contexts.ThreadErrors">
            <summary>
            Use this class if you want to "pack" many database errors at once, or
            use it's statics methods to add, get or clear errors.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.#ctor(System.Object)">
            <summary>
            Creates a new database error "pack".
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.Dispose">
            <summary>
            Disposes this object and maybe throws and exception if there
            are errors.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.GetGlobalErrors">
            <summary>
            Gets the errors that are not specific to a data-context.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.GetErrorsDictionary">
            <summary>
            Gets the dictionary with the errors.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.ClearErrors">
            <summary>
            Clear all the errors.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.AddError(System.Object)">
            <summary>
            Adds an error to the packet, or throws an exception immediatelly.
            In general errors are string, but you can add any object if you
            know how to use it later.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.AddError(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Adds a PropertyError object to the error list.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.AddError``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Object)">
            <summary>
            Adds a PropertyError object to the error list.
            Uses an expression to know what propertyInfo to use.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ThreadErrors.GetSimpleAllErrorsMessage">
            <summary>
            Gets a single string with all errors.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ThreadErrors.HasErrors">
            <summary>
            Gets a value indicating if there are errors packed.
            </summary>
        </member>
        <member name="E:Pfz.Threading.Contexts.ThreadErrors.ThrowingException">
            <summary>
            Event invoked when an exception is about to be thrown.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Contexts.ThrowingExceptionEventArgs">
            <summary>
            Arguments used by ThreadErrors.ThrowingException
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ThrowingExceptionEventArgs.GlobalErrors">
            <summary>
            Gets a hashset with all the errors that are not bound to an specific data source.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ThrowingExceptionEventArgs.ErrorsDictionary">
            <summary>
            Gets a dictionary with all data-sources and its errors.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ThrowingExceptionEventArgs.WasHandled">
            <summary>
            Gets or sets a value indicating that the event was handled properly.
            This can avoid the exception to be thrown.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Contexts.ValidationException">
            <summary>
            Exception that is thrown by DatabaseValidationErrors class.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.#ctor">
            <summary>
            Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.#ctor(System.String)">
            <summary>
            Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.#ctor(System.String,System.Exception)">
            <summary>
            Exception pattern.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Reads the ValidationErrorsDictionary.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Restores the validation error dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.#ctor(System.Collections.Generic.HashSet{System.Object},System.Collections.Generic.Dictionary{System.Object,System.Collections.Generic.HashSet{System.Object}})">
            <summary>
            Creates the exception based on a validation errors dictionary.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Contexts.ValidationException.GetSimpleAllErrorsMessage">
            <summary>
            Gets all errors as a single message.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ValidationException.MessageFormatManyErrorsInSingleRecord">
            <summary>
            Gets or sets the format of the message used when there are many errors
            in a single record.
            {0} is the number of errors.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ValidationException.MessageFormatManyErrorsInManyRecords">
            <summary>
            Gets or sets the message format used when there are many errors,
            in many records.
            {0} is the number of errors.
            {1} is the number of records.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ValidationException.GlobalErrors">
            <summary>
            Gets a hashset with errors not bound to an specific data-source.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Contexts.ValidationException.ErrorsDictionary">
            <summary>
            Gets the dictionary with the errors that caused this exception.
            </summary>
        </member>
        <member name="T:Pfz.Threading.HighPrecisionTimer">
            <summary>
            Class that creates a Timer that runs an action at given intervals.
            It is high precision (and cpu intensive). It tries to compensate slowdowns, but never stacks.
            </summary>
        </member>
        <member name="M:Pfz.Threading.HighPrecisionTimer.#ctor(System.Action,System.Double,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="M:Pfz.Threading.HighPrecisionTimer.#ctor(System.Action,System.TimeSpan,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="P:Pfz.Threading.HighPrecisionTimer.Action">
            <summary>
            Gets the action that's run by this timer.
            </summary>
        </member>
        <member name="P:Pfz.Threading.HighPrecisionTimer.Interval">
            <summary>
            Gets the interval in which the action is run.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ManagedAutoResetEvent">
            <summary>
            An auto reset event that uses only Monitor methods to work, avoiding
            operating system events.
            </summary>
        </member>
        <member name="T:Pfz.Threading.IEventWait">
            <summary>
            Interface implemented by PooledEventWait. And, thanks to StructuralCaster, can be used to
            access custom EventWait objects.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IEventWait.WaitOne">
            <summary>
            Waits for this event to be signalled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IEventWait.WaitOne(System.Int32)">
            <summary>
            Waits for this event to be signalled or times-out.
            Returns if the object was signalled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IEventWait.WaitOne(System.TimeSpan)">
            <summary>
            Waits for this event to be signalled or times-out.
            Returns if the object was signalled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IEventWait.Reset">
            <summary>
            Resets (unsignals) this wait event.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IEventWait.Set">
            <summary>
            Sets (signals) this wait event.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.#ctor">
            <summary>
            Creates a new event, not signaled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates a new event, letting you say if it starts signaled or not.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.Dispose">
            <summary>
            Disposes this event. After disposing, it is always set.
            Calling Reset will not work and it will not throw exceptions, so you can
            dispose it when there are threads waiting on it.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.Reset">
            <summary>
            Resets this event (makes it non-signaled).
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.Set">
            <summary>
            Signals the event, releasing one thread waiting on it.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.WaitOne">
            <summary>
            Waits until this event is signaled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.WaitOne(System.Int32)">
            <summary>
            Waits until this event is signaled or until the timeout arrives.
            Return of true means it was signaled, false means timeout.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedAutoResetEvent.WaitOne(System.TimeSpan)">
            <summary>
            Waits until this event is signaled or until the timeout arrives.
            Return of true means it was signaled, false means timeout.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ManagedAutoResetEvent.WasDisposed">
            <summary>
            Gets a value indicating if this event was disposed.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ManagedManualResetEvent">
            <summary>
            A manual reset event that uses only Monitor methods to work, avoiding
            operating system events.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.#ctor">
            <summary>
            Creates a new event, not signaled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates a new event, letting you say if it starts signaled or not.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.Dispose">
            <summary>
            Disposes this event. After disposing, it is always set.
            Calling Reset will not work and it will not throw exceptions, so you can
            dispose it when there are threads waiting on it.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.Reset">
            <summary>
            Resets this event (makes it non-signaled).
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.Set">
            <summary>
            Signals the event, releasing any threads waiting on it.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.WaitOne">
            <summary>
            Waits until this event is signaled.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.WaitOne(System.Int32)">
            <summary>
            Waits until this event is signaled or until the timeout arrives.
            Return of true means it was signaled, false means timeout.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedManualResetEvent.WaitOne(System.TimeSpan)">
            <summary>
            Waits until this event is signaled or until the timeout arrives.
            Return of true means it was signaled, false means timeout.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ManagedManualResetEvent.WasDisposed">
            <summary>
            Gets a value indicating if this event was disposed.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ManagedSemaphore">
            <summary>
            A semaphore class that uses only Monitor class for synchronization, avoiding
            operating system events.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.#ctor(System.Int32)">
            <summary>
            Creates a new semaphore with the given availableCount.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.Dispose">
            <summary>
            Disposes this semaphore.
            If you try to enter or exit it after this, the action will always return immediately.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.Enter">
            <summary>
            Enters the actual semaphore.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.Enter(System.Int32)">
            <summary>
            Enters the actual semaphore with the given count value.
            If you pass a value higher than the one used to create it, you will dead-lock (at least until
            the semaphore is disposed).
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.Exit">
            <summary>
            Exits the semaphore. One thread can enter it and another one exit it. There is no check for that.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ManagedSemaphore.Exit(System.Int32)">
            <summary>
            Exits the semaphore the given amount. One thread can enter it and another one exit it. There is no check for that.
            </summary>
        </member>
        <member name="P:Pfz.Threading.ManagedSemaphore.WasDisposed">
            <summary>
            Gets a value indicating if this semaphore was disposed.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.YieldUpgradeableLock">
            <summary>
            Class returned by UpgradeableLock method.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.YieldUpgradeableLock.DisposableUpgrade">
            <summary>
            Upgrades this lock to a write-lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.YieldUpgradeableLock.Upgrade">
            <summary>
            Upgrades the lock to a write-lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.YieldUpgradeableLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ThreadedEnumerator`1">
            <summary>
            This class is responsible for holding an UnsafeThreadedEnumerator.
            When disposed or collected it will release the thread used by such
            enumerator.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.CreateFromAction(Pfz.Threading.EnumeratorAction{`0})">
            <summary>
            Creates a new threaded enumerator from the given action.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.#ctor(Pfz.Threading.Unsafe.UnsafeThreadedEnumerator{`0})">
            <summary>
            Creates a new ThreadedEnumerator from an unsafe one.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.op_Implicit(Pfz.Threading.Unsafe.UnsafeThreadedEnumerator{`0})~Pfz.Threading.ThreadedEnumerator{`0}">
            <summary>
            Implicit cast from UnsafeThreadedEnumerator to ThreadedEnumerator.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.BeginUpdate">
            <summary>
            Tells the enumerator to start the next step.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.EndUpdate(`0@)">
            <summary>
            Wait until the next frame ends.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedEnumerator`1.Update(`0@)">
            <summary>
            Tells the enumerator to process the next step and wait for it.
            </summary>
        </member>
        <member name="T:Pfz.Threading.EnumeratorAction`1">
            <summary>
            Delegate type to create enumerators based on actions.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer">
            <summary>
            Class that creates a Timer that runs an action at given intervals.
            It is high precision (and cpu intensive). It tries to compensate slowdowns, but never stacks.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.#ctor(System.Action,System.Double,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.#ctor(System.Action,System.TimeSpan,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.Dispose">
            <summary>
            Releases the Timer thread immediatelly.
            Note that, if such thread is already running, it will continue to the end of the action,
            and only then will be returned to the pool, but the Timer will return immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer._CheckUndisposed">
            <summary>
            Throws an exception if this object was already disposed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.WasDisposed">
            <summary>
            Gets a value indicating if this object was already disposed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.Action">
            <summary>
            Gets the action that's run by this timer.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeHighPrecisionTimer.Interval">
            <summary>
            Gets the interval in which the action is run.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1">
            <summary>
            Inheriting this class you can program an enumerator in the most "natural" way, doing what it need to do
            and then returning and waiting until a new value is requested.
            This uses another thread to effectivelly do the enumeration and this is why it is considered "unsafe", as
            forgetting to dispose keeps a thread alive. So, to manipulate it assign it to a ThreadedIterator
            variable.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1.Dispose">
            <summary>
            Asks the actual enumerator to finish, or releases all resources if it is already finished.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1.OnRun">
            <summary>
            Must be implemented to run the enumerator code.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1.YieldReturnNoException(`0)">
            <summary>
            Must be called to return value.
            If it returns false, the iterator was disposed, so it is better to return immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1.YieldReturn(`0)">
            <summary>
            Similar to YieldReturnNoException, but throws an exception of type IteratorDisposedException
            if the enumerator was already disposed, this way you don't need to check for the bool result.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeThreadedEnumerator`1.UseParallelLimit">
            <summary>
            Gets or sets a valud indicating if this threaded enumerator should be limited by the number of CPUs.
            If the limit is used, only one parallel iterator/enumerator is allowed per cpu.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe._UnsafeThreadedEnumeratorFromAction`1.#ctor(Pfz.Threading.EnumeratorAction{`0})">
            <summary>
            Creates a new instance of this class prepared to run the given animation.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe._UnsafeThreadedEnumeratorFromAction`1.OnRun">
            <summary>
            Runs the action used to construct this class.
            </summary>
        </member>
        <member name="T:Pfz.Threading.DisposableThreadLocal">
            <summary>
            This is an equivalent to ThreadLocal class, but it calls Dispose on it items when it is disposed, or when its threads dies.
            </summary>
        </member>
        <member name="M:Pfz.Threading.DisposableThreadLocal.GetOrCreateValue(System.Func{System.IDisposable})">
            <summary>
            Gets the value for the actual thread, creating it if needed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.DisposableThreadLocal.Value">
            <summary>
            Gets or sets the value for the actual thread.
            </summary>
        </member>
        <member name="T:Pfz.Threading.DisposableThreadLocal`1">
            <summary>
            A typed version of DisposableThreadLocal.
            </summary>
        </member>
        <member name="M:Pfz.Threading.DisposableThreadLocal`1.#ctor">
            <summary>
            Creates a new instance of DisposableThreadLocal.
            </summary>
        </member>
        <member name="M:Pfz.Threading.DisposableThreadLocal`1.GetOrCreateValue(System.Func{System.IDisposable})">
            <summary>
            Gets the value for the actual thread, creating it if needed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.DisposableThreadLocal`1.Value">
            <summary>
            Gets or sets the value for the actual thread.
            </summary>
        </member>
        <member name="T:Pfz.Threading.IRunnable`1">
            <summary>
            IRunnable interface that accepts a parameter.
            </summary>
        </member>
        <member name="M:Pfz.Threading.IRunnable`1.Run(`0)">
            <summary>
            Runs this object.
            </summary>
        </member>
        <member name="T:Pfz.Threading.IteratorAction">
            <summary>
            Action used by Iterators. The yieldReturn will return to the caller.
            </summary>
        </member>
        <member name="T:Pfz.Threading.IteratorDisposedException">
            <summary>
            Exception thrown by the threaded iterator when the iterator is disposed.
            If you catch this exception, always rethrow it!
            </summary>
        </member>
        <member name="T:Pfz.Threading.LockConfiguration">
            <summary>
            This class only configures what to do when a dead-lock occurs while
            acquiring a lock with PfzMonitorLockExtensions or with 
            PfzReaderWriterLockExtensions.
            </summary>
        </member>
        <member name="P:Pfz.Threading.LockConfiguration.DefaultLockTimeout">
            <summary>
            Gets or sets the default timeout for LockWithTimeout method.
            This value is in milliseconds.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.MonitorLockDisposer">
            <summary>
            Class returned by MonitorLockExtensions.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.MonitorLockDisposer.Finalize">
            <summary>
            Throws an exception, as we can simple release the lock (destructors runs from another thread).
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.MonitorLockDisposer.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.MonitorLockDisposer.SwitchLock(System.Object)">
            <summary>
            First locks the new object and then releases the old lock.
            This is NOT abort-safe.
            </summary>
        </member>
        <member name="T:Pfz.Threading.NonStackingTimer">
            <summary>
            Class that creates a Timer that runs an action at given intervals.
            The intervals are always counted after the end of the last action, so it does not stack or tries to
            compensate delays.
            </summary>
        </member>
        <member name="M:Pfz.Threading.NonStackingTimer.#ctor(System.Action,System.Int32,System.Boolean,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="P:Pfz.Threading.NonStackingTimer.Action">
            <summary>
            Gets the action that's run by this timer.
            </summary>
        </member>
        <member name="P:Pfz.Threading.NonStackingTimer.Interval">
            <summary>
            Gets the interval in which the action is run.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.ReadLockDisposer">
            <summary>
            Class returned by ReaderWriterLockExtensions when acquiring a read-lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.ReadLockDisposer.Finalize">
            <summary>
            Throws an exception, as we can simple release the lock (destructors runs from another thread).
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.ReadLockDisposer.Dispose">
            <summary>
            Releases the lock, if it is still hold.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.ReadLockDisposer.SwitchLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            First locks the new object and then releases the old lock.
            This is NOT abort-safe.
            </summary>
        </member>
        <member name="T:Pfz.Threading.RunnableRunner">
            <summary>
            Class that creates a thread to run Runnables as messages. It only creates 
            one thread to process all messages. Use it only when you know you want to
            process many messages asynchronously, but don't want (or can't) use ThreadPool 
            threads.
            </summary>
        </member>
        <member name="M:Pfz.Threading.RunnableRunner.#ctor(Pfz.Threading.IRunnable)">
            <summary>
            Creates a new instance of this class.
            </summary>
        </member>
        <member name="M:Pfz.Threading.RunnableRunner.Run(Pfz.Threading.IRunnable)">
            <summary>
            Post the given action to be run.
            </summary>
        </member>
        <member name="M:Pfz.Threading.RunnableRunner.Run``1(Pfz.Threading.IRunnable{``0},``0)">
            <summary>
            Post the given action to be run.
            </summary>
        </member>
        <member name="P:Pfz.Threading.RunnableRunner.PendingCount">
            <summary>
            Gets the number of action still unprocessed.
            </summary>
        </member>
        <member name="T:Pfz.Threading.SafeAbort">
            <summary>
            Class that allows thread-aborts to be done in a relativelly safe manner.
            </summary>
        </member>
        <member name="M:Pfz.Threading.SafeAbort.AbortIfSafe(System.Threading.Thread,Pfz.Threading.SafeAbortMode,System.Object)">
            <summary>
            Aborts a thread only if it is safe to do so, taking the abort mode into account (which may
            range from only guaranteeing that IDisposable objects will be fully constructed, up to 
            guaranteeing all "using" blocks to work and even doing some user validations).
            Returns if the Thread.Abort() was called or not.
            </summary>
        </member>
        <member name="M:Pfz.Threading.SafeAbort.Abort(System.Threading.Thread,System.Int32,System.Int32,System.Int32,System.Boolean,System.Object)">
            <summary>
            Aborts a thread, trying to use the safest abort mode, until the unsafest one.
            The number of retries is also the expected number of milliseconds trying to abort.
            </summary>
        </member>
        <member name="E:Pfz.Threading.SafeAbort.Validating">
            <summary>
            Event invoked by AbortIfSafe if user validations are valid and when it is unsure if the thread
            is in a safe situation or not.
            </summary>
        </member>
        <member name="T:Pfz.Threading.SafeAbortEventArgs">
            <summary>
            Argument passed to SafeAbort.Verifying when AbortIfSafe is still unsure if it is safe
            to abort the thread and is able to run user validations.
            </summary>
        </member>
        <member name="P:Pfz.Threading.SafeAbortEventArgs.Thread">
            <summary>
            Gets the Thread that is about to be aborted.
            </summary>
        </member>
        <member name="P:Pfz.Threading.SafeAbortEventArgs.StackTrace">
            <summary>
            Gets the StackTrace of the thread about to be aborted.
            </summary>
        </member>
        <member name="P:Pfz.Threading.SafeAbortEventArgs.StackFrames">
            <summary>
            Get the StackFrames of the thread to be aborted.
            </summary>
        </member>
        <member name="P:Pfz.Threading.SafeAbortEventArgs.CanAbort">
            <summary>
            Gets or sets a value indicating if the thread can be aborted.
            </summary>
        </member>
        <member name="T:Pfz.Threading.SafeAbortMode">
            <summary>
            Determines how SafeAbort.AbortIfSafe method will verify for safety.
            </summary>
        </member>
        <member name="F:Pfz.Threading.SafeAbortMode.RunAllValidations">
            <summary>
            All validations, including user-registered validations, will be used.
            This has all the guarantees over using keyword and IDisposable objects, and also runs
            the SafeAbort.Validating event, to check for some user function that is not returning
            an IDisposable object but may be changing global data, which must be reverted.
            </summary>
        </member>
        <member name="F:Pfz.Threading.SafeAbortMode.IgnoreUserValidations">
            <summary>
            Only user validations will be ignored. This will guarantee that all "using" blocks will work,
            or any code that creates a disposable object, does a try, and finalizes it.
            </summary>
        </member>
        <member name="F:Pfz.Threading.SafeAbortMode.AllowUsingsToFail">
            <summary>
            This will only guarantee that IDisposable objects will be fully created, but even an using block may fail,
            as the abort can happen between the object construction and its store to a local variable.
            </summary>
        </member>
        <member name="T:Pfz.Threading.ThreadedIterator">
            <summary>
            This class is responsible for holding an UnsafeThreadedIterator.
            When disposed or collected it will release the thread used by such
            iterator.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.CreateFromAction(Pfz.Threading.IteratorAction)">
            <summary>
            Creates a new threaded iterator from the given action.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.#ctor(Pfz.Threading.Unsafe.UnsafeThreadedIterator)">
            <summary>
            Creates a new ThreadedIterator from an unsafe one.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.op_Implicit(Pfz.Threading.Unsafe.UnsafeThreadedIterator)~Pfz.Threading.ThreadedIterator">
            <summary>
            Implicit cast from UnsafeThreadedIterator to ThreadedIterator.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.BeginUpdate">
            <summary>
            Tells the iterator to start the next step.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.EndUpdate">
            <summary>
            Wait until the next frame ends.
            </summary>
        </member>
        <member name="M:Pfz.Threading.ThreadedIterator.Update">
            <summary>
            Tells the iterator to process the next step and wait for it.
            </summary>
        </member>
        <member name="T:Pfz.Threading.TicksOrIncrement">
            <summary>
            Class that returns the value of DateTime.Now.Ticks when GetValue is called 
            but also guarantees that two calls will generate different values, even if
            they are done one just after the other.
            </summary>
        </member>
        <member name="M:Pfz.Threading.TicksOrIncrement.GetNext">
            <summary>
            Gets a new DateTime.Now.Ticks value or a random incremented value if
            this is a call done at the same microsecond of the last one.
            </summary>
        </member>
        <member name="P:Pfz.Threading.TicksOrIncrement.RandomIncrement">
            <summary>
            Gets or sets the random value used as the increment factor when
            two calls are made in the same microsecond.
            </summary>
        </member>
        <member name="P:Pfz.Threading.TicksOrIncrement.TotalProcesses">
            <summary>
            Gets or sets a value that is seen as the total number of processes using
            TicksOrIncrement. So, together with ProcessId, values are guaranteed to
            be exclusive.
            </summary>
        </member>
        <member name="P:Pfz.Threading.TicksOrIncrement.ProcessId">
            <summary>
            Gets or sets the processid used to guarantee that never two process using
            TicksOrIncrement will get the same value.
            </summary>
        </member>
        <member name="T:Pfz.Threading.UnlimitedThreadPool">
            <summary>
            This is a thread pool that, different from System.Threading.ThreadPool,
            does not have a thread limit and the threads are not background while
            they run. Comparing to the system ThreadPool, it is better if the
            thread can enter in wait mode. This happens when one thread has a 
            "fast" process, but can only terminate after another thread returns.
            
            This thread pool keeps threads that were used alive at the next collection.
            So, for a thread to die, it must not be used between 2 collections.
            </summary>
        </member>
        <member name="M:Pfz.Threading.UnlimitedThreadPool.Run(System.Action)">
            <summary>
            Runs an action in another thread. Uses an existing thread if one is 
            available or creates a new one if none are available, so this call will
            not hang if there are no available threads.
            </summary>
            <param name="action">The function to execute.</param>
        </member>
        <member name="M:Pfz.Threading.UnlimitedThreadPool.Run(System.Action{System.Object},System.Object)">
            <summary>
            Runs an action in another thread. Uses an existing thread if one is 
            available or creates a new one if none are available, so this call will
            not hang if there are no available threads.
            </summary>
            <param name="action">The function to execute.</param>
            <param name="parameter">The object passed as parameter to the action.</param>
        </member>
        <member name="M:Pfz.Threading.UnlimitedThreadPool.Run``1(System.Action{``0},``0)">
            <summary>
            Runs an action in another thread. Uses an existing thread if one is 
            available or creates a new one if none are available, so this call will
            not hang if there are no available threads.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="action">The function to execute.</param>
            <param name="parameter">The object passed as parameter to the action.</param>
        </member>
        <member name="T:Pfz.Threading.Unsafe.UnsafeNonStackingTimer">
            <summary>
            Class that creates a Timer that runs an action at given intervals.
            The intervals are always counted after the end of the last action, so it does not stack or tries to
            compensate delays.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeNonStackingTimer.#ctor(System.Action,System.Int32,System.Boolean,System.String)">
            <summary>
            Creates a new timer that will run the given action at the given interval milliseconds.
            If exclusiveThreadName is not null, then a new Thread will be created. Otherwise, a 
            UnlimitedThreadPool thread will be used.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeNonStackingTimer.Dispose">
            <summary>
            Releases the Timer thread immediatelly.
            Note that, if such thread is already running, it will continue to the end of the action,
            and only then will be returned to the pool, but the Timer will return immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeNonStackingTimer._CheckUndisposed">
            <summary>
            Throws an exception if this object was already disposed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeNonStackingTimer.WasDisposed">
            <summary>
            Gets a value indicating if this object was already disposed.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeNonStackingTimer.Action">
            <summary>
            Gets the action that's run by this timer.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeNonStackingTimer.Interval">
            <summary>
            Gets the interval in which the action is run.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Unsafe.UnsafeRunnableRunner">
            <summary>
            Class that creates a thread to run Actions as messages. It only creates 
            one thread to process all messages. Use it only when you know you want to
            process many messages asynchronously, but don't want (or can't) use ThreadPool 
            threads.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeRunnableRunner.#ctor(Pfz.Threading.IRunnable)">
            <summary>
            Creates a new action runner.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeRunnableRunner.Dispose(System.Boolean)">
            <summary>
            Frees all used resources.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeRunnableRunner.Run(Pfz.Threading.IRunnable)">
            <summary>
            Enqueues and runs the given runnable asynchronously.
            </summary>
            <param name="runnable">The runnable to run.</param>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeRunnableRunner.Run``1(Pfz.Threading.IRunnable{``0},``0)">
            <summary>
            Enqueues and runs the given runnable asynchronously.
            </summary>
            <param name="runnable">The runnable to run.</param>
            <param name="value">The value to pass to the runnable.</param>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeRunnableRunner.PendingCount">
            <summary>
            Gets the number of pending items. Use this if you want to stablish a maximum.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Unsafe.UnsafeThreadedIterator">
            <summary>
            Inheriting this class you can program an iterator in the most "natural" way, doing what it need to do
            and then waiting to do the next action.
            This uses another thread to effectivelly do the iteration and this is why it is considered "unsafe", as
            forgetting to dispose keeps a thread alive. So, to manipulate it assign it to a ThreadedIterator
            variable.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedIterator.Dispose">
            <summary>
            Asks the actual iterator to finish, or releases all resources if it is already finished.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedIterator.OnRun">
            <summary>
            Must be implemented to run the iterator code.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedIterator.YieldReturnNoException">
            <summary>
            Must be called when ending a frame.
            If it returns false, the iterator was disposed, so it is better to return immediatelly.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe.UnsafeThreadedIterator.YieldReturn">
            <summary>
            Similar to YieldReturnNoException, but throws an exception of type IteratorDisposedException
            if the iterator was already disposed, this way you don't need to check for the bool result.
            </summary>
        </member>
        <member name="P:Pfz.Threading.Unsafe.UnsafeThreadedIterator.UseParallelLimit">
            <summary>
            Gets or sets a valud indicating if this threaded iterator should be limited by the number of CPUs.
            If the limit is used, only one parallel iterator/enumerator is allowed per cpu.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe._UnsafeThreadedIteratorFromAction.#ctor(Pfz.Threading.IteratorAction)">
            <summary>
            Creates a new instance of this class prepared to run the given animation.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Unsafe._UnsafeThreadedIteratorFromAction.OnRun">
            <summary>
            Runs the action used to construct this class.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.UpgradeableLockDisposer">
            <summary>
            Class returned by ReaderWriterLockExtensions when acquiring an 
            upgradeable lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.UpgradeableLockDisposer.Finalize">
            <summary>
            Throws an exception, as we can simple release the lock (destructors runs from another thread).
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.UpgradeableLockDisposer.Dispose">
            <summary>
            Releases the lock if it is still hold.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.UpgradeableLockDisposer.SwitchLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            First locks the new object and then releases the old lock.
            This is NOT abort-safe.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.WriteLockDisposer">
            <summary>
            Class returned by the ReaderWriterLockExtensions when a
            write-lock is obtained.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.WriteLockDisposer.Finalize">
            <summary>
            Throws an exception, as we can simple release the lock (destructors runs from another thread).
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.WriteLockDisposer.Dispose">
            <summary>
            Releases the lock if it is still hold.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.WriteLockDisposer.SwitchLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            First locks the new object and then releases the old lock.
            This is NOT abort-safe.
            </summary>
        </member>
        <member name="T:Pfz.Threading.YieldReaderWriterLock">
            <summary>
            A reader writer lock that uses Yield if it does not have the lock. If the locks are held for to much time, this is time consuming.
            In my general tests, it is about 10 times faster than ReaderWriterLockSlim class.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLock.ReadLock">
            <summary>
            Acquires a read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLock.UpgradeableLock">
            <summary>
            Acquires a upgradeable read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLock.WriteLock">
            <summary>
            Acquires a write lock that must be used in a using clause.
            If you are using a UpgradeableLock use the Upgrade method of the
            YieldUpgradeableLock instead or you will cause a dead-lock.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.YieldReadLock">
            <summary>
            Class returned by ReadLock method.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.YieldReadLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:Pfz.Threading.Disposers.YieldWriteLock">
            <summary>
            Class returned by WriteLock method.
            </summary>
        </member>
        <member name="M:Pfz.Threading.Disposers.YieldWriteLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:Pfz.Threading.YieldReaderWriterLockSlim">
            <summary>
            A "real slim" reader writer lock.
            Many readers can read at a time and only one writer is allowed.
            Reads can be recursive, but a try to a recursive write will cause a dead-lock.
            Note that this is a struct, so don't assign it to a local variable.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.EnterReadLock">
            <summary>
            Enters a read lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.ExitReadLock">
            <summary>
            Exits a read-lock. Take care not to exit more times than you entered, as there is no check for that.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.EnterUpgradeableLock">
            <summary>
            Enters an upgradeable lock (it is a read lock, but it can be upgraded).
            Only one upgradeable lock is allowed at a time.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.ExitUpgradeableLock">
            <summary>
            Exits a previously obtained upgradeable lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.UpgradeToWriteLock">
            <summary>
            upgrades to write-lock. You must already own a Upgradeable lock and you must first exit the write lock then the Upgradeable lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.ExitUpgradedLock">
            <summary>
            Releases the Upgradeable lock and the upgraded version of it (the write lock)
            at the same time.
            Releasing the write lock and the upgradeable lock has the same effect, but
            it's slower.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.EnterWriteLock">
            <summary>
            Enters write-lock.
            </summary>
        </member>
        <member name="M:Pfz.Threading.YieldReaderWriterLockSlim.ExitWriteLock">
            <summary>
            Exits write lock. Take care to exit only when you entered, as there is no check for that.
            </summary>
        </member>
        <member name="T:Pfz.UnsafeBuffer">
            <summary>
            Class similar to Buffer, but has its unsafe methods available to anyone.
            </summary>
        </member>
        <member name="M:Pfz.UnsafeBuffer.BlockCopy(System.Byte*,System.Byte*,System.Int32)">
            <summary>
            Copies bytes from a source to a destination.
            </summary>
        </member>
    </members>
</doc>
